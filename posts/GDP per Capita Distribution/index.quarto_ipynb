{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Distribution of Global GDP: Visualizing Income Mountains\"\n",
        "\n",
        "description: \"Explores the global distribution of GDP, representing income disparities as visual mountains to highlight the contrast between wealthy and less wealthy regions.\"\n",
        "\n",
        "categories: \"Economy\"\n",
        "\n",
        "date: \"2025-01-25\"\n",
        "\n",
        "keywords: [\"Daily Income\"]\n",
        "\n",
        "jupyter: python3\n",
        "\n",
        "format:\n",
        "  html:\n",
        "    code-fold: true\n",
        "---\n",
        "\n",
        "\n",
        "## Summary\n",
        "\n",
        "A plot that shows the evolution of `Daily Income` based on GDP per Capita (\\$US constant 2017) from 1900 to 2100.\n"
      ],
      "id": "62cbe7db"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "#| echo: true\n",
        "#| output: false\n",
        "#| warning: false\n",
        "# Libraries\n",
        "# =====================================================================\n",
        "import requests\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "import matplotlib.animation as animation\n",
        "import matplotlib.ticker as ticker\n",
        "from matplotlib.lines import Line2D\n",
        "\n",
        "# Data Extraction (Countries)\n",
        "# =====================================================================\n",
        "# Extract JSON and bring data to a dataframe\n",
        "url = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\n",
        "response = requests.get(url)\n",
        "data = response.json()\n",
        "df = pd.DataFrame(data)\n",
        "df = pd.DataFrame.from_dict(data, orient='index').reset_index()\n",
        "df_countries = df.rename(columns={'index': 'iso3'})\n",
        "\n",
        "# Data Extraction (GAPMINDER)\n",
        "# ====================================================================\n",
        "# URL Github\n",
        "urlgap = 'https://raw.githubusercontent.com/guillemmaya92/world_map/refs/heads/main/gapminder-gdp.csv'\n",
        "dfgap = pd.read_csv(urlgap, delimiter=';')\n",
        "\n",
        "# Transform iso3 to upper and divide population\n",
        "dfgap['iso3'] = dfgap['iso3'].str.upper()\n",
        "dfgap['pop'] = dfgap['pop'] // 1000000\n",
        "\n",
        "# Filter years\n",
        "dfgap = dfgap[dfgap['year'] > 1900]\n",
        "\n",
        "# Data Manipulation\n",
        "# ====================================================================\n",
        "# Copy Dataframe\n",
        "df = dfgap.copy()\n",
        "\n",
        "# Create a list\n",
        "dfs = []\n",
        "\n",
        "# Interpolate monthly data\n",
        "for iso3 in df['iso3'].unique():\n",
        "    temp_df = df[df['iso3'] == iso3].copy()\n",
        "    temp_df['date'] = pd.to_datetime(temp_df['year'], format='%Y')\n",
        "    temp_df = temp_df[['date', 'pop', 'gdpc']]\n",
        "    temp_df = temp_df.set_index('date').resample('ME').mean().interpolate(method='linear').reset_index()\n",
        "    temp_df['iso3'] = iso3\n",
        "    temp_df['year'] = temp_df['date'].dt.year \n",
        "    dfs.append(temp_df)\n",
        "\n",
        "# Concat dataframes    \n",
        "df = pd.concat(dfs, ignore_index=True)\n",
        "\n",
        "# Merge queries\n",
        "df = df.merge(df_countries, how='left', left_on='iso3', right_on='iso3')\n",
        "df = df[['iso3', 'Country', 'Region', 'year', 'date', 'pop', 'gdpc']]\n",
        "df = df[df['Region'].notna()]\n",
        "\n",
        "# Expand dataframe with population\n",
        "columns = df.columns\n",
        "df = np.repeat(df.values, df['pop'].astype(int), axis=0)\n",
        "df = pd.DataFrame(df, columns=columns)\n",
        "\n",
        "# Function to create a new distribution\n",
        "def distribution(df):\n",
        "    average = df['gdpc'].mean()\n",
        "    inequality = np.geomspace(1, 10, len(df))\n",
        "    df['gdpcd'] = inequality * (average / np.mean(inequality))\n",
        "    \n",
        "    return df\n",
        "\n",
        "df = df.groupby(['iso3', 'year', 'date']).apply(distribution).reset_index(drop=True)\n",
        "\n",
        "# Logarithmic distribution\n",
        "df['gdpcdl'] = np.log(df['gdpcd'])\n",
        "\n",
        "# Logarithmic distribution\n",
        "df['Region'] = np.where(df['iso3'] == 'CHN', 'China', df['Region'])\n",
        "df['Region'] = np.where(df['iso3'] == 'USA', 'USA', df['Region'])\n",
        "\n",
        "print(df)\n",
        "\n",
        "# Data Visualization\n",
        "# =====================================================================\n",
        "# Seaborn figure style\n",
        "sns.set(style=\"whitegrid\")\n",
        "\n",
        "# Create a palette\n",
        "fig, ax = plt.subplots(figsize=(16, 9))\n",
        "\n",
        "def update(year):\n",
        "    ax.clear()\n",
        "    df_filtered = df[df['date'] == year]\n",
        "\n",
        "    # Calculate mean value\n",
        "    max_value = df_filtered['gdpcdl'].max()\n",
        "    mean_value = df_filtered['gdpcdl'].median()\n",
        "    mean_value_r = df_filtered['gdpcd'].median() // 365\n",
        "    population = len(df_filtered)\n",
        "    year = df_filtered['date'].min()\n",
        "\n",
        "    # Custom palette area\n",
        "    custom_area = {\n",
        "        'China': '#e3d6b1',\n",
        "        'Asia': '#fff3d0',\n",
        "        'Europe': '#ccdccd',\n",
        "        'Oceania': '#90a8b7',\n",
        "        'USA': '#f09c9c',\n",
        "        'Americas': '#fdcccc',\n",
        "        'Africa': '#ffe3ce'\n",
        "    }\n",
        "\n",
        "    # Custom palette line\n",
        "    custom_line = {\n",
        "        'China': '#cc9d0e',\n",
        "        'Asia': '#FFC107',\n",
        "        'Europe': '#004d00',\n",
        "        'Oceania': '#003366',\n",
        "        'USA': '#a60707',\n",
        "        'Americas': '#FF0000',\n",
        "        'Africa': '#FF6F00'\n",
        "    }\n",
        "\n",
        "    # Region Order\n",
        "    order_region = ['China', 'Asia', 'Africa', 'USA', 'Americas', 'Europe', 'Oceania'] \n",
        "\n",
        "    # Create kdeplot area and lines\n",
        "    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_area, fill=True, linewidth=1, linestyle='-', ax=ax)\n",
        "    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_line, fill=False, linewidth=1, linestyle='-', ax=ax)\n",
        "\n",
        "    # Configuration grid and labels\n",
        "    ax.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n",
        "    ax.text(0, 1.02, 'Evolution by region from 1980 to 2030', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n",
        "    ax.set_xlabel('Daily Income PPP ($US constant 2017)', fontsize=10, fontweight='bold')\n",
        "    ax.set_ylabel('Frequency of total population', fontsize=10, fontweight='bold')\n",
        "    ax.tick_params(axis='x', labelsize=9)\n",
        "    ax.tick_params(axis='y', labelsize=9)\n",
        "    ax.grid(axis='x')\n",
        "    ax.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n",
        "    ax.set_ylim(0, 0.4)\n",
        "    ax.set_xlim(3, 13)\n",
        "\n",
        "    # Functions to round axis\n",
        "    def round_to_nearest(value, step=0.05):\n",
        "        return np.floor(value / step) * step\n",
        "    def round_to_nearest_1(value, step=0.25):\n",
        "        return int(np.round(value / step) * step)\n",
        "    def round_to_nearest_5(value, step=5):\n",
        "        return int(np.round(value / step) * step)\n",
        "    def round_to_nearest_10(value, step=10):\n",
        "        return int(np.round(value / step) * step)\n",
        "    def round_to_nearest_50(value, step=50):\n",
        "        return int(np.round(value / step) * step)\n",
        "\n",
        "    # Inverse logarhitmic xticklabels\n",
        "    xticks = np.linspace(3, 13, num=12)\n",
        "    ax.set_xticks(xticks)\n",
        "    ax.set_xticklabels([\n",
        "        # Condition 1\n",
        "        f'{round_to_nearest(np.exp(tick) / 365) :.2f}' if np.exp(tick) / 365 < 1 else\n",
        "        # Condition 2\n",
        "        f'{round_to_nearest_1(np.exp(tick) / 365)}' if np.exp(tick) / 365 < 5 else\n",
        "        # Condition 3\n",
        "        f'{round_to_nearest_5(np.exp(tick) / 365)}' if np.exp(tick) / 365 < 100 else\n",
        "        # Condition 4\n",
        "        f'{round_to_nearest_10(np.exp(tick) / 365)}' if np.exp(tick) / 365 < 500 else\n",
        "        # Condition 5\n",
        "        f'{round_to_nearest_50(np.exp(tick) / 365)}' if np.exp(tick) / 365 < 10000 else\n",
        "        # Condition 6\n",
        "        f'{int(np.exp(tick) / 365)}'\n",
        "        for tick in xticks\n",
        "    ])\n",
        "\n",
        "    # Black color to xticklabels\n",
        "    for label in ax.get_xticklabels():\n",
        "        label.set_color('black')\n",
        "        \n",
        "    # Median line\n",
        "    ax.axvline(mean_value, color='darkred', linestyle='--', linewidth=0.5)\n",
        "    ax.text(\n",
        "        x=mean_value + (max_value * 0.01),\n",
        "        y=ax.get_ylim()[1] * 0.98,\n",
        "        s=f'Median: {mean_value_r:,.1f} $/day',\n",
        "        color='darkred',\n",
        "        verticalalignment='top',\n",
        "        horizontalalignment='left',\n",
        "        fontsize=10,\n",
        "        weight='bold')\n",
        "\n",
        "    # Population label\n",
        "    ax.text(\n",
        "        0.02,\n",
        "        0.98,\n",
        "        s=f'Population: {population:,.0f} (M)',\n",
        "        transform=ax.transAxes,\n",
        "        color='dimgrey',\n",
        "        verticalalignment='top',\n",
        "        horizontalalignment='left',\n",
        "        fontsize=10,\n",
        "        weight='bold')\n",
        "\n",
        "    # Add Year label\n",
        "    formatted_date = year.strftime('%Y') \n",
        "    ax.text(1, 1.06, f'{formatted_date}',\n",
        "        transform=ax.transAxes,\n",
        "        fontsize=22, ha='right', va='top',\n",
        "        fontweight='bold', color='#D3D3D3')\n",
        "\n",
        "    # Add a custom legend\n",
        "    legend_elements = [Line2D([0], [0], color=color, lw=4, label=region, alpha=0.4) for region, color in custom_line.items()]\n",
        "    legend = ax.legend(handles=legend_elements, title='Region', title_fontsize='10', fontsize='9', loc='upper right')\n",
        "    plt.setp(legend.get_title(), fontweight='bold')\n",
        "\n",
        "    # Add label \"poorest\" and \"richest\"\n",
        "    plt.text(0, -0.065, 'Poorest',\n",
        "        transform=ax.transAxes,\n",
        "        fontsize=10, fontweight='bold', color='darkred', ha='left', va='center')\n",
        "    plt.text(0.95, -0.065, 'Richest',\n",
        "        transform=ax.transAxes,\n",
        "        fontsize=10, fontweight='bold', color='darkblue', va='center')\n",
        "\n",
        "    # Add Data Source\n",
        "    plt.text(0, -0.1, 'Data Source: Gapminder (2024). GDP per capita Dataset.', \n",
        "        transform=plt.gca().transAxes, \n",
        "        fontsize=8, \n",
        "        color='gray')\n",
        "\n",
        "    # Add Notes\n",
        "    plt.text(0, -0.12, 'Notes: The distribution of values, based on GDP per capita, has been calculated using a logarithmic scale ranging from 1 to 10 and adjusted proportionally to the population size of each country.', \n",
        "        transform=plt.gca().transAxes,\n",
        "        fontsize=8, \n",
        "        color='gray')\n",
        "\n",
        "# Configurate animation\n",
        "years = sorted(df['date'].unique())\n",
        "ani = animation.FuncAnimation(fig, update, frames=years, repeat=False, interval=50, blit=False)\n",
        "\n",
        "# Save the animation :)\n",
        "ani.save('C:/Users/guillem.maya/Downloads/FIG_GDP_Capita_Distribution_PPP_KDEPLOT_GAPMINDER.webp', writer='imagemagick', fps=80)\n",
        "\n",
        "# Print it!\n",
        "plt.show()"
      ],
      "id": "9e0c179f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![](FIG_GDP_Capita_Distribution_PPP_KDEPLOT_GAPMINDER.webp){.lightbox width=\"125%\"}"
      ],
      "id": "5b122e66"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\guill\\AppData\\Roaming\\Python\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}