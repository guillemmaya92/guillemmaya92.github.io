[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\n\n\n\n\nNov 3, 2025\n\n\nGlobal temperature anomalies\n\n\n\n\nNov 3, 2025\n\n\nGlobal North: Inequalities in GDP per Capita\n\n\n\n\nOct 9, 2025\n\n\nGlobalization Eras\n\n\n\n\nSep 21, 2025\n\n\nGlobal Patterns in Wealth-Income Ratios\n\n\n\n\nAug 14, 2025\n\n\nCapital is Back: From Labor to Capital in the Modern Economy\n\n\n\n\nJul 11, 2025\n\n\nEuropean Regions NUTS2: GDP per Capita\n\n\n\n\nJun 21, 2025\n\n\nGlobal structure economy: A vision of GDP per capita and population\n\n\n\n\nMay 18, 2025\n\n\nLorenz Curves: A global and national perspectives\n\n\n\n\nApr 9, 2025\n\n\nAlquiler de vivienda en Catalunya: Distribución de precios\n\n\n\n\nMar 4, 2025\n\n\nBitcoin Wealth Distribution: Utopian vision of narcocapitalism\n\n\n\n\nFeb 17, 2025\n\n\nExploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity\n\n\n\n\nJan 25, 2025\n\n\nDistribution of Global GDP: Visualizing Income Mountains\n\n\n\n\nDec 27, 2024\n\n\nBitcoin Logarithmic Trends: Analysis since each halving\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "posts/202502-flags-inequalities-gdp/index.html",
    "href": "posts/202502-flags-inequalities-gdp/index.html",
    "title": "Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity",
    "section": "",
    "text": "A plot that shows the current Inequalities in capital productivity.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport requests\nimport plotly.graph_objects as go\nimport numpy as np\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - IMF (1980-2030)\n# =====================================================================\n#Parametro\nparameters = ['NGDPD', 'PPPGDP', 'LP']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Pivot Parameter to columns and filter nulls\ndf_imf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\n\n# Filter after 2024\ndf_imf = df_imf[df_imf['Year'] == 2024]\n\n# Data Manipulation\n# =====================================================================\n# Concat and filter dataframes\ndf = df_imf.dropna(subset=['NGDPD', 'PPPGDP', 'LP'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year', 'NGDPD', 'PPPGDP', 'LP']]\ndf = df[df['Cod_Currency'].notna()]\n\n# Calculate PPP\ndf = df.groupby(['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year'])[['NGDPD', 'PPPGDP', 'LP']].sum()\ndf = df.reset_index()\ndf['PPP'] = df['NGDPD'] / df['PPPGDP']\ndf['NGDPDPC'] = df['NGDPD'] / df['LP']\ndf['PPPPC'] = df['PPPGDP'] / df['LP']\n\n# Calculate Average Weight and Percent\ndf['AVG_Weight'] = df.groupby('Year')['NGDPDPC'].transform(lambda x: np.average(x, weights=df.loc[x.index, 'LP']))\ndf['Percent'] = df['NGDPD'] / df.groupby('Year')['NGDPD'].transform('sum')\n\n# Filtering\ndf = df[df['NGDPDPC'] &lt; 115 ]\ndf = df[df['PPP'] &lt; 1.25]\ndf = df[~df['ISO2'].isin(['SZ', 'VA', 'NC', 'CI', 'MW', 'SS', 'MY'])]\n\n# Data Visualization\n# =====================================================================\nfig = go.Figure()\n\n# Tamaño de los marcadores\nmarker_size = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 100 + 3\nline_width  = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 4 + 0.5\n\n# Add scatter plot\nfig.add_trace(go.Scatter(\n    x=df[\"PPP\"],\n    y=df[\"NGDPDPC\"],\n    mode='markers',\n    text=df[\"Country\"],\n    marker=dict(\n        size=marker_size,\n        color=\"rgba(0,0,0,0)\",\n        line=dict(\n            width=line_width,\n            color='black'\n        )\n    ),\n    hovertemplate=\"&lt;b&gt;Country:&lt;/b&gt; %{text}&lt;br&gt;\" +\n                  \"&lt;b&gt;GDP per Capita:&lt;/b&gt; $%{y:.2f}&lt;br&gt;\" + \n                  \"&lt;b&gt;PPP:&lt;/b&gt; $%{x:.2f}&lt;extra&gt;&lt;/extra&gt;\",\n    showlegend=False\n))\n\n# Add flag images to scatterplot\nfor i, row in df.iterrows():\n    country_iso = row[\"ISO2\"]\n    \n    # Calculate image size\n    image_size = marker_size[i] * 0.21\n\n    # Add the flag image\n    fig.add_layout_image(\n        dict(\n            source=f\"https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/{country_iso}.png\",\n            xref=\"x\",\n            yref=\"y\",\n            xanchor=\"center\",\n            yanchor=\"middle\",\n            x=row[\"PPP\"],\n            y=row[\"NGDPDPC\"],\n            sizex=image_size,\n            sizey=image_size,\n            sizing=\"contain\",\n            opacity=0.8,\n            layer=\"above\"\n        )\n    )\n    \n# Modeling a line trend\nz = np.polyfit(df['PPP'], df['NGDPDPC'], 2, w=df['NGDPD'])\np = np.poly1d(z)\nx_range = np.linspace(df['PPP'].min(), df['PPP'].max(), 100)\ny_range = p(x_range)\n\n# Add the line trend\nfig.add_trace(go.Scatter(\n    x=x_range,\n    y=y_range,\n    mode='lines',\n    name='Trend Line',\n    line=dict(color='darkred', width=0.5),\n    showlegend=False\n))\n\n# Add red and green shapes\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=0, x1=1,\n    y0=0, y1=1,\n    fillcolor=\"red\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=1, x1=1.2,\n    y0=0, y1=1,\n    fillcolor=\"green\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\n\n# Configuration plot\nfig.update_layout(\n    title=\"&lt;b&gt;Global Inequalities in GDP per Capita&lt;/b&gt;\",\n    title_x=0.11,\n    title_font=dict(size=16),\n    annotations=[\n        dict(\n            text=\"Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.07,\n            showarrow=False,\n            font=dict(size=11)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; IMF World Economic Outlook Database, 2024\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.13,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"2024\",\n            xref=\"paper\", \n            yref=\"paper\",\n            x=1, \n            y=1.1,\n            showarrow=False,\n            font=dict(size=22, color='lightgray', weight='bold'),\n            align=\"right\"\n        )\n    ],\n    xaxis=dict(\n        title=\"&lt;b&gt;GAP Between PPP and Market Exchange Rate&lt;/b&gt;\",\n        range=[0, 1.2],\n        tickvals=[i * 1.2 / 6 for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    yaxis=dict(\n        title=\"&lt;b&gt;GDP per Capita (US$)&lt;/b&gt;\",\n        range=[0, 120],\n        tickvals=[i * 120 / 6 for i in range(7)],\n        ticktext=[f\"{int(i * 120 / 6)}k\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    height=750,\n    width=750,\n    plot_bgcolor=\"white\",\n    paper_bgcolor=\"white\"\n)\n\n# Add a custom legend\nsize_legend = ['Smaller', 'Middle', 'Bigger']\nsize_values = [5, 10, 20]\n\nfor label, size in zip(size_legend, size_values):\n    fig.add_trace(go.Scatter(\n        x=[None],\n        y=[None],\n        mode='markers',\n        marker=dict(\n            size=size,\n            color=\"rgba(0,0,0,0)\",\n            line=dict(\n                width=1,\n                color='black'\n            )\n        ),\n        legendgroup='size',\n        showlegend=True,\n        name=f'{label}'\n    ))\n\nfig.update_layout(\n    legend=dict(\n        title=dict(text='&lt;b&gt;   GDP Scale&lt;/b&gt;'), \n        font=dict(size=11),\n        x=0.025,\n        y=0.95,\n        xanchor='left',\n        bgcolor='white',\n        bordercolor='black',\n        borderwidth=1\n    )\n)\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202502-flags-inequalities-gdp/index.html#summary",
    "href": "posts/202502-flags-inequalities-gdp/index.html#summary",
    "title": "Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity",
    "section": "",
    "text": "A plot that shows the current Inequalities in capital productivity.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport requests\nimport plotly.graph_objects as go\nimport numpy as np\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - IMF (1980-2030)\n# =====================================================================\n#Parametro\nparameters = ['NGDPD', 'PPPGDP', 'LP']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Pivot Parameter to columns and filter nulls\ndf_imf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\n\n# Filter after 2024\ndf_imf = df_imf[df_imf['Year'] == 2024]\n\n# Data Manipulation\n# =====================================================================\n# Concat and filter dataframes\ndf = df_imf.dropna(subset=['NGDPD', 'PPPGDP', 'LP'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year', 'NGDPD', 'PPPGDP', 'LP']]\ndf = df[df['Cod_Currency'].notna()]\n\n# Calculate PPP\ndf = df.groupby(['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year'])[['NGDPD', 'PPPGDP', 'LP']].sum()\ndf = df.reset_index()\ndf['PPP'] = df['NGDPD'] / df['PPPGDP']\ndf['NGDPDPC'] = df['NGDPD'] / df['LP']\ndf['PPPPC'] = df['PPPGDP'] / df['LP']\n\n# Calculate Average Weight and Percent\ndf['AVG_Weight'] = df.groupby('Year')['NGDPDPC'].transform(lambda x: np.average(x, weights=df.loc[x.index, 'LP']))\ndf['Percent'] = df['NGDPD'] / df.groupby('Year')['NGDPD'].transform('sum')\n\n# Filtering\ndf = df[df['NGDPDPC'] &lt; 115 ]\ndf = df[df['PPP'] &lt; 1.25]\ndf = df[~df['ISO2'].isin(['SZ', 'VA', 'NC', 'CI', 'MW', 'SS', 'MY'])]\n\n# Data Visualization\n# =====================================================================\nfig = go.Figure()\n\n# Tamaño de los marcadores\nmarker_size = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 100 + 3\nline_width  = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 4 + 0.5\n\n# Add scatter plot\nfig.add_trace(go.Scatter(\n    x=df[\"PPP\"],\n    y=df[\"NGDPDPC\"],\n    mode='markers',\n    text=df[\"Country\"],\n    marker=dict(\n        size=marker_size,\n        color=\"rgba(0,0,0,0)\",\n        line=dict(\n            width=line_width,\n            color='black'\n        )\n    ),\n    hovertemplate=\"&lt;b&gt;Country:&lt;/b&gt; %{text}&lt;br&gt;\" +\n                  \"&lt;b&gt;GDP per Capita:&lt;/b&gt; $%{y:.2f}&lt;br&gt;\" + \n                  \"&lt;b&gt;PPP:&lt;/b&gt; $%{x:.2f}&lt;extra&gt;&lt;/extra&gt;\",\n    showlegend=False\n))\n\n# Add flag images to scatterplot\nfor i, row in df.iterrows():\n    country_iso = row[\"ISO2\"]\n    \n    # Calculate image size\n    image_size = marker_size[i] * 0.21\n\n    # Add the flag image\n    fig.add_layout_image(\n        dict(\n            source=f\"https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/{country_iso}.png\",\n            xref=\"x\",\n            yref=\"y\",\n            xanchor=\"center\",\n            yanchor=\"middle\",\n            x=row[\"PPP\"],\n            y=row[\"NGDPDPC\"],\n            sizex=image_size,\n            sizey=image_size,\n            sizing=\"contain\",\n            opacity=0.8,\n            layer=\"above\"\n        )\n    )\n    \n# Modeling a line trend\nz = np.polyfit(df['PPP'], df['NGDPDPC'], 2, w=df['NGDPD'])\np = np.poly1d(z)\nx_range = np.linspace(df['PPP'].min(), df['PPP'].max(), 100)\ny_range = p(x_range)\n\n# Add the line trend\nfig.add_trace(go.Scatter(\n    x=x_range,\n    y=y_range,\n    mode='lines',\n    name='Trend Line',\n    line=dict(color='darkred', width=0.5),\n    showlegend=False\n))\n\n# Add red and green shapes\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=0, x1=1,\n    y0=0, y1=1,\n    fillcolor=\"red\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=1, x1=1.2,\n    y0=0, y1=1,\n    fillcolor=\"green\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\n\n# Configuration plot\nfig.update_layout(\n    title=\"&lt;b&gt;Global Inequalities in GDP per Capita&lt;/b&gt;\",\n    title_x=0.11,\n    title_font=dict(size=16),\n    annotations=[\n        dict(\n            text=\"Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.07,\n            showarrow=False,\n            font=dict(size=11)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; IMF World Economic Outlook Database, 2024\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.13,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"2024\",\n            xref=\"paper\", \n            yref=\"paper\",\n            x=1, \n            y=1.1,\n            showarrow=False,\n            font=dict(size=22, color='lightgray', weight='bold'),\n            align=\"right\"\n        )\n    ],\n    xaxis=dict(\n        title=\"&lt;b&gt;GAP Between PPP and Market Exchange Rate&lt;/b&gt;\",\n        range=[0, 1.2],\n        tickvals=[i * 1.2 / 6 for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    yaxis=dict(\n        title=\"&lt;b&gt;GDP per Capita (US$)&lt;/b&gt;\",\n        range=[0, 120],\n        tickvals=[i * 120 / 6 for i in range(7)],\n        ticktext=[f\"{int(i * 120 / 6)}k\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    height=750,\n    width=750,\n    plot_bgcolor=\"white\",\n    paper_bgcolor=\"white\"\n)\n\n# Add a custom legend\nsize_legend = ['Smaller', 'Middle', 'Bigger']\nsize_values = [5, 10, 20]\n\nfor label, size in zip(size_legend, size_values):\n    fig.add_trace(go.Scatter(\n        x=[None],\n        y=[None],\n        mode='markers',\n        marker=dict(\n            size=size,\n            color=\"rgba(0,0,0,0)\",\n            line=dict(\n                width=1,\n                color='black'\n            )\n        ),\n        legendgroup='size',\n        showlegend=True,\n        name=f'{label}'\n    ))\n\nfig.update_layout(\n    legend=dict(\n        title=dict(text='&lt;b&gt;   GDP Scale&lt;/b&gt;'), \n        font=dict(size=11),\n        x=0.025,\n        y=0.95,\n        xanchor='left',\n        bgcolor='white',\n        bordercolor='black',\n        borderwidth=1\n    )\n)\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202412-bitcoin-halvings/index.html",
    "href": "posts/202412-bitcoin-halvings/index.html",
    "title": "Bitcoin Logarithmic Trends: Analysis since each halving",
    "section": "",
    "text": "A plot that shows the logarithmic price of Bitcoin over each halving period.\n\n\nCode\n# Libraries\n# ==============================================================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport requests\n\n# Get API Data\n# ==============================================================================\n# Create a df with final year dates\ndp = pd.DataFrame({'date': pd.date_range(start='2010-12-31', end='2024-12-31', freq='Y')})\ndp['to_ts'] = dp['date'].apply(lambda x: int(pd.to_datetime(x).timestamp()))\n\n# Create an empty list\ndataframes = []\n\n# Iterate API with each date\nfor to_ts in dp['to_ts']:\n    # Build an URL with parameters and transform data\n    url = f\"https://min-api.cryptocompare.com/data/v2/histoday?fsym=BTC&tsym=USD&limit=365&toTs={to_ts}\"\n    response = requests.get(url)\n    data = response.json().get(\"Data\", {}).get(\"Data\", [])\n    df = pd.DataFrame([\n        {\n            \"symbol\": \"BTCUSD\",\n            \"date\": pd.to_datetime(entry[\"time\"], unit=\"s\").date(),\n            \"open\": entry[\"open\"],\n            \"close\": entry[\"close\"],\n            \"low\": entry[\"low\"],\n            \"high\": entry[\"high\"],\n            \"volume\": entry[\"volumeto\"]\n        }\n        for entry in data\n    ])\n    dataframes.append(df)\n# Combine all df into one\nbtc = pd.concat(dataframes, ignore_index=True)\n\n# DataSet 0 - Halving\n#================================================================================\nhalving = {'halving': [0 , 1, 2, 3, 4],\n           'date': ['2009-01-03', '2012-11-28', '2016-07-09', '2020-05-11', '2024-04-20'] \n           }\n\nhalving = pd.DataFrame(halving)\nhalving['date'] = pd.to_datetime(halving['date'])\n\n# DataSet 1 - BTC Price\n# ==============================================================================\n# Prepare dataset\nbtc = btc.drop_duplicates()\nbtc['date'] = pd.to_datetime(btc['date'])\nbtc['year_month'] = btc['date'].dt.strftime('%Y-%m')\nbtc = btc.set_index('date')\nbtc = btc.asfreq('D').ffill()\nbtc = btc.reset_index()\nbtc.sort_values(by=['date'], inplace=True)\nbtc = pd.merge(btc, halving, on='date', how='left')\nbtc['halving'].fillna(method='ffill', inplace=True)\nbtc['halving'].fillna(0, inplace=True)\nbtc['halving'] = btc['halving'].astype(int)\nbtc['first_close'] = btc.groupby('halving')['close'].transform('first')\nbtc['increase'] = (btc['close'] - btc['first_close']) / btc['first_close'] * 100\nbtc['days'] = btc.groupby('halving').cumcount() + 1\nbtc['closelog'] = np.log10(btc['close'])\nbtc = btc[btc['halving'] &gt;= 1]\nbtc['daystotal'] = btc.groupby('symbol').cumcount() + 1\n\n# Graph 1 - SEABORN\n# ==============================================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Colors Background\nregions = [\n    (0, 500, '#6B8E23'), # Green\n    (500, 1000, '#FF4500'), # Red\n    (1000, 1500, '#FFA500') # Orange\n    ]  \n\n# Colors Palette Lines\nlines = {\n    0: '#E0E0E0',  # Very Light Grey\n    1: '#C0C0C0',  # Light Grey\n    2: '#808080',  # Medium Grey\n    3: '#404040',  # Dark Grey\n    4: '#8B0000'   # Red\n}\n\n# Seaborn to plot a graph\nsns.set(style=\"whitegrid\", rc={\"grid.color\": \"0.95\", \"axes.grid.axis\": \"y\"})\nplt.figure(figsize=(16, 9))\nsns.lineplot(x='days', y='closelog', hue='halving', data=btc, markers=True, palette=lines, linewidth=1)\n\n# Add region colors in the background\nfor start, end, color in regions:\n    plt.axvspan(start, end, color=color, alpha=0.05)\n\n# Title and axis\nplt.title('Bitcoin Logarithmic Trends: Analysis Since Each Halving', fontsize=16, fontweight='bold', pad=20)\nplt.xlabel('Days',  fontsize=10, fontweight='bold')\nplt.ylabel('Log Price', fontsize=10, fontweight='bold')\nplt.xlim(0, 1500)\nplt.xticks(range(0, 1501, 125), fontsize=9)\nplt.tick_params(axis='both', labelsize=8)\nplt.yticks(fontsize=9)\n\n# Custom legend\nlegend = plt.legend(title=\"Halving\", loc='lower right', fontsize=8, title_fontsize='10')\nnew_title = 'Dates:'\nlegend.set_title(new_title)\nnew_labels = ['1st Halving: 2012-11-28 to 2016-07-09', '2nd Halving: 2016-07-09 to 2020-05-11', '3rd Halving: 2020-05-11 to 2024-04-20', '4th Halving: 2024-04-20 to present'] # Adjust the number of labels according to your data\nfor text, new_label in zip(legend.texts, new_labels):\n    text.set_text(new_label)\n\n# Maximo First 750 days\nbtc1 = btc[(btc['days'] &gt;= 0) & (btc['days'] &lt;= 750)]\nfor halving, group in btc1.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='*', color='darkgoldenrod', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgoldenrod')\n\n# Min Between 500 and 1000 days\nbtc2 = btc[(btc['days'] &gt;= 500) & (btc['days'] &lt;= 1000)]\nfor halving, group in btc2.groupby('halving'):\n    min_value = group['closelog'].min()\n    min_row = group[group['closelog'] == min_value].iloc[0]\n    plt.plot(min_row['days'], min_row['closelog'] - 0.05, marker='v', color='darkred', markersize=5)\n    plt.text(min_row['days'], min_row['closelog'] -0.15, f'{min_row[\"close\"]:,.0f} ({min_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkred')\n\n# Max After 750 days \nbtc3 = btc[(btc['days'] &gt;= 750) & (btc['days'] &lt;= 1500)]\nfor halving, group in btc3.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='^', color='darkgreen', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgreen')\n\n# Custom Last Dots\nmax_vals = btc.groupby('halving').agg({'closelog': 'last', 'days': 'max'}).reset_index()\nfor index, row in max_vals.iterrows():\n    plt.plot(row['days'], row['closelog'], 'ro', markersize=2)\n\n# Custom Line labels\nfor halving, group in btc.groupby('halving'):\n    last_point = group.iloc[-1]\n    x = last_point['days']\n    y = last_point['closelog']\n    max_days = group['days'].max()\n    plt.text(x + 8, y, f'Halving {halving}\\n{max_days} days', color=lines[halving], fontsize=8, ha='left', va='center')\n    \n# Add Year Label\ncurrent_year_month = btc['year_month'].max() \nplt.text(1, 1.05, f'{current_year_month}',\n    transform=plt.gca().transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nplt.text(0, -0.065, 'Data Source: CryptoCompare', \n         transform=plt.gca().transAxes, \n         fontsize=8, \n         color='gray')\n\n# Adjust layout\nplt.tight_layout()\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202412-bitcoin-halvings/index.html#summary",
    "href": "posts/202412-bitcoin-halvings/index.html#summary",
    "title": "Bitcoin Logarithmic Trends: Analysis since each halving",
    "section": "",
    "text": "A plot that shows the logarithmic price of Bitcoin over each halving period.\n\n\nCode\n# Libraries\n# ==============================================================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport requests\n\n# Get API Data\n# ==============================================================================\n# Create a df with final year dates\ndp = pd.DataFrame({'date': pd.date_range(start='2010-12-31', end='2024-12-31', freq='Y')})\ndp['to_ts'] = dp['date'].apply(lambda x: int(pd.to_datetime(x).timestamp()))\n\n# Create an empty list\ndataframes = []\n\n# Iterate API with each date\nfor to_ts in dp['to_ts']:\n    # Build an URL with parameters and transform data\n    url = f\"https://min-api.cryptocompare.com/data/v2/histoday?fsym=BTC&tsym=USD&limit=365&toTs={to_ts}\"\n    response = requests.get(url)\n    data = response.json().get(\"Data\", {}).get(\"Data\", [])\n    df = pd.DataFrame([\n        {\n            \"symbol\": \"BTCUSD\",\n            \"date\": pd.to_datetime(entry[\"time\"], unit=\"s\").date(),\n            \"open\": entry[\"open\"],\n            \"close\": entry[\"close\"],\n            \"low\": entry[\"low\"],\n            \"high\": entry[\"high\"],\n            \"volume\": entry[\"volumeto\"]\n        }\n        for entry in data\n    ])\n    dataframes.append(df)\n# Combine all df into one\nbtc = pd.concat(dataframes, ignore_index=True)\n\n# DataSet 0 - Halving\n#================================================================================\nhalving = {'halving': [0 , 1, 2, 3, 4],\n           'date': ['2009-01-03', '2012-11-28', '2016-07-09', '2020-05-11', '2024-04-20'] \n           }\n\nhalving = pd.DataFrame(halving)\nhalving['date'] = pd.to_datetime(halving['date'])\n\n# DataSet 1 - BTC Price\n# ==============================================================================\n# Prepare dataset\nbtc = btc.drop_duplicates()\nbtc['date'] = pd.to_datetime(btc['date'])\nbtc['year_month'] = btc['date'].dt.strftime('%Y-%m')\nbtc = btc.set_index('date')\nbtc = btc.asfreq('D').ffill()\nbtc = btc.reset_index()\nbtc.sort_values(by=['date'], inplace=True)\nbtc = pd.merge(btc, halving, on='date', how='left')\nbtc['halving'].fillna(method='ffill', inplace=True)\nbtc['halving'].fillna(0, inplace=True)\nbtc['halving'] = btc['halving'].astype(int)\nbtc['first_close'] = btc.groupby('halving')['close'].transform('first')\nbtc['increase'] = (btc['close'] - btc['first_close']) / btc['first_close'] * 100\nbtc['days'] = btc.groupby('halving').cumcount() + 1\nbtc['closelog'] = np.log10(btc['close'])\nbtc = btc[btc['halving'] &gt;= 1]\nbtc['daystotal'] = btc.groupby('symbol').cumcount() + 1\n\n# Graph 1 - SEABORN\n# ==============================================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Colors Background\nregions = [\n    (0, 500, '#6B8E23'), # Green\n    (500, 1000, '#FF4500'), # Red\n    (1000, 1500, '#FFA500') # Orange\n    ]  \n\n# Colors Palette Lines\nlines = {\n    0: '#E0E0E0',  # Very Light Grey\n    1: '#C0C0C0',  # Light Grey\n    2: '#808080',  # Medium Grey\n    3: '#404040',  # Dark Grey\n    4: '#8B0000'   # Red\n}\n\n# Seaborn to plot a graph\nsns.set(style=\"whitegrid\", rc={\"grid.color\": \"0.95\", \"axes.grid.axis\": \"y\"})\nplt.figure(figsize=(16, 9))\nsns.lineplot(x='days', y='closelog', hue='halving', data=btc, markers=True, palette=lines, linewidth=1)\n\n# Add region colors in the background\nfor start, end, color in regions:\n    plt.axvspan(start, end, color=color, alpha=0.05)\n\n# Title and axis\nplt.title('Bitcoin Logarithmic Trends: Analysis Since Each Halving', fontsize=16, fontweight='bold', pad=20)\nplt.xlabel('Days',  fontsize=10, fontweight='bold')\nplt.ylabel('Log Price', fontsize=10, fontweight='bold')\nplt.xlim(0, 1500)\nplt.xticks(range(0, 1501, 125), fontsize=9)\nplt.tick_params(axis='both', labelsize=8)\nplt.yticks(fontsize=9)\n\n# Custom legend\nlegend = plt.legend(title=\"Halving\", loc='lower right', fontsize=8, title_fontsize='10')\nnew_title = 'Dates:'\nlegend.set_title(new_title)\nnew_labels = ['1st Halving: 2012-11-28 to 2016-07-09', '2nd Halving: 2016-07-09 to 2020-05-11', '3rd Halving: 2020-05-11 to 2024-04-20', '4th Halving: 2024-04-20 to present'] # Adjust the number of labels according to your data\nfor text, new_label in zip(legend.texts, new_labels):\n    text.set_text(new_label)\n\n# Maximo First 750 days\nbtc1 = btc[(btc['days'] &gt;= 0) & (btc['days'] &lt;= 750)]\nfor halving, group in btc1.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='*', color='darkgoldenrod', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgoldenrod')\n\n# Min Between 500 and 1000 days\nbtc2 = btc[(btc['days'] &gt;= 500) & (btc['days'] &lt;= 1000)]\nfor halving, group in btc2.groupby('halving'):\n    min_value = group['closelog'].min()\n    min_row = group[group['closelog'] == min_value].iloc[0]\n    plt.plot(min_row['days'], min_row['closelog'] - 0.05, marker='v', color='darkred', markersize=5)\n    plt.text(min_row['days'], min_row['closelog'] -0.15, f'{min_row[\"close\"]:,.0f} ({min_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkred')\n\n# Max After 750 days \nbtc3 = btc[(btc['days'] &gt;= 750) & (btc['days'] &lt;= 1500)]\nfor halving, group in btc3.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='^', color='darkgreen', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgreen')\n\n# Custom Last Dots\nmax_vals = btc.groupby('halving').agg({'closelog': 'last', 'days': 'max'}).reset_index()\nfor index, row in max_vals.iterrows():\n    plt.plot(row['days'], row['closelog'], 'ro', markersize=2)\n\n# Custom Line labels\nfor halving, group in btc.groupby('halving'):\n    last_point = group.iloc[-1]\n    x = last_point['days']\n    y = last_point['closelog']\n    max_days = group['days'].max()\n    plt.text(x + 8, y, f'Halving {halving}\\n{max_days} days', color=lines[halving], fontsize=8, ha='left', va='center')\n    \n# Add Year Label\ncurrent_year_month = btc['year_month'].max() \nplt.text(1, 1.05, f'{current_year_month}',\n    transform=plt.gca().transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nplt.text(0, -0.065, 'Data Source: CryptoCompare', \n         transform=plt.gca().transAxes, \n         fontsize=8, \n         color='gray')\n\n# Adjust layout\nplt.tight_layout()\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Guillem Maya",
    "section": "",
    "text": "From nowhere, delving into the challenges faced by modern economies. I am an enthusiast of data and economics, interested in exploring and uncovering a genuine comprehension of the global world. Focused on social inequalities and the development of a sustainable economy, I pursue a transversal approach that examines these concepts from a holistic and multidisciplinary perspective.\n\n\n Back to top"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "Guillem Maya",
    "section": "",
    "text": "Download pdf"
  },
  {
    "objectID": "cv.html#about-me",
    "href": "cv.html#about-me",
    "title": "Guillem Maya",
    "section": "About me",
    "text": "About me"
  },
  {
    "objectID": "cv.html#experience",
    "href": "cv.html#experience",
    "title": "Guillem Maya",
    "section": "Experience",
    "text": "Experience"
  },
  {
    "objectID": "cv.html#education",
    "href": "cv.html#education",
    "title": "Guillem Maya",
    "section": "Education",
    "text": "Education"
  },
  {
    "objectID": "cv.html#language",
    "href": "cv.html#language",
    "title": "Guillem Maya",
    "section": "Language",
    "text": "Language"
  },
  {
    "objectID": "cv.html#skills",
    "href": "cv.html#skills",
    "title": "Guillem Maya",
    "section": "Skills",
    "text": "Skills"
  },
  {
    "objectID": "posts/202410-polar-axis/index.html",
    "href": "posts/202410-polar-axis/index.html",
    "title": "Polar Axis demonstration",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: A line plot on a polar axis\n\n\n\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "posts/202501-distribution-mountains-gdpc/index.html",
    "href": "posts/202501-distribution-mountains-gdpc/index.html",
    "title": "Distribution of Global GDP: Visualizing Income Mountains",
    "section": "",
    "text": "A plot that shows the evolution of Daily Income based on GDP per Capita ($US constant 2017) from 1900 to 2100.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.ticker as ticker\nfrom matplotlib.lines import Line2D\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'iso3'})\n\n# Data Extraction (GAPMINDER)\n# ====================================================================\n# URL Github\nurlgap = 'https://raw.githubusercontent.com/guillemmaya92/world_map/refs/heads/main/gapminder-gdp.csv'\ndfgap = pd.read_csv(urlgap, delimiter=';')\n\n# Transform iso3 to upper and divide population\ndfgap['iso3'] = dfgap['iso3'].str.upper()\ndfgap['pop'] = dfgap['pop'] // 1000000\n\n# Filter years\ndfgap = dfgap[dfgap['year'] &gt; 1900]\n\n# Data Manipulation\n# ====================================================================\n# Copy Dataframe\ndf = dfgap.copy()\n\n# Create a list\ndfs = []\n\n# Interpolate monthly data\nfor iso3 in df['iso3'].unique():\n    temp_df = df[df['iso3'] == iso3].copy()\n    temp_df['date'] = pd.to_datetime(temp_df['year'], format='%Y')\n    temp_df = temp_df[['date', 'pop', 'gdpc']]\n    temp_df = temp_df.set_index('date').resample('ME').mean().interpolate(method='linear').reset_index()\n    temp_df['iso3'] = iso3\n    temp_df['year'] = temp_df['date'].dt.year \n    dfs.append(temp_df)\n\n# Concat dataframes    \ndf = pd.concat(dfs, ignore_index=True)\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='iso3', right_on='iso3')\ndf = df[['iso3', 'Country', 'Region', 'year', 'date', 'pop', 'gdpc']]\ndf = df[df['Region'].notna()]\n\n# Expand dataframe with population\ncolumns = df.columns\ndf = np.repeat(df.values, df['pop'].astype(int), axis=0)\ndf = pd.DataFrame(df, columns=columns)\n\n# Function to create a new distribution\ndef distribution(df):\n    average = df['gdpc'].mean()\n    inequality = np.geomspace(1, 10, len(df))\n    df['gdpcd'] = inequality * (average / np.mean(inequality))\n    \n    return df\n\ndf = df.groupby(['iso3', 'year', 'date']).apply(distribution).reset_index(drop=True)\n\n# Logarithmic distribution\ndf['gdpcdl'] = np.log(df['gdpcd'])\n\n# Logarithmic distribution\ndf['Region'] = np.where(df['iso3'] == 'CHN', 'China', df['Region'])\ndf['Region'] = np.where(df['iso3'] == 'USA', 'USA', df['Region'])\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\n\n# Create a palette\nfig, ax = plt.subplots(figsize=(16, 9))\n\ndef update(year):\n    ax.clear()\n    df_filtered = df[df['date'] == year]\n\n    # Calculate mean value\n    max_value = df_filtered['gdpcdl'].max()\n    mean_value = df_filtered['gdpcdl'].median()\n    mean_value_r = df_filtered['gdpcd'].median() // 365\n    population = len(df_filtered)\n    year = df_filtered['date'].min()\n\n    # Custom palette area\n    custom_area = {\n        'China': '#e3d6b1',\n        'Asia': '#fff3d0',\n        'Europe': '#ccdccd',\n        'Oceania': '#90a8b7',\n        'USA': '#f09c9c',\n        'Americas': '#fdcccc',\n        'Africa': '#ffe3ce'\n    }\n\n    # Custom palette line\n    custom_line = {\n        'China': '#cc9d0e',\n        'Asia': '#FFC107',\n        'Europe': '#004d00',\n        'Oceania': '#003366',\n        'USA': '#a60707',\n        'Americas': '#FF0000',\n        'Africa': '#FF6F00'\n    }\n\n    # Region Order\n    order_region = ['China', 'Asia', 'Africa', 'USA', 'Americas', 'Europe', 'Oceania'] \n\n    # Create kdeplot area and lines\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_area, fill=True, linewidth=1, linestyle='-', ax=ax)\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_line, fill=False, linewidth=1, linestyle='-', ax=ax)\n\n    # Configuration grid and labels\n    ax.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n    ax.text(0, 1.02, 'Evolution by region from 1980 to 2030', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n    ax.set_xlabel('Daily Income PPP ($US constant 2017)', fontsize=10, fontweight='bold')\n    ax.set_ylabel('Frequency of total population', fontsize=10, fontweight='bold')\n    ax.tick_params(axis='x', labelsize=9)\n    ax.tick_params(axis='y', labelsize=9)\n    ax.grid(axis='x')\n    ax.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n    ax.set_ylim(0, 0.4)\n    ax.set_xlim(3, 13)\n\n    # Functions to round axis\n    def round_to_nearest(value, step=0.05):\n        return np.floor(value / step) * step\n    def round_to_nearest_1(value, step=0.25):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_5(value, step=5):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_10(value, step=10):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_50(value, step=50):\n        return int(np.round(value / step) * step)\n\n    # Inverse logarhitmic xticklabels\n    xticks = np.linspace(3, 13, num=12)\n    ax.set_xticks(xticks)\n    ax.set_xticklabels([\n        # Condition 1\n        f'{round_to_nearest(np.exp(tick) / 365) :.2f}' if np.exp(tick) / 365 &lt; 1 else\n        # Condition 2\n        f'{round_to_nearest_1(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 5 else\n        # Condition 3\n        f'{round_to_nearest_5(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 100 else\n        # Condition 4\n        f'{round_to_nearest_10(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 500 else\n        # Condition 5\n        f'{round_to_nearest_50(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 10000 else\n        # Condition 6\n        f'{int(np.exp(tick) / 365)}'\n        for tick in xticks\n    ])\n\n    # Black color to xticklabels\n    for label in ax.get_xticklabels():\n        label.set_color('black')\n        \n    # Median line\n    ax.axvline(mean_value, color='darkred', linestyle='--', linewidth=0.5)\n    ax.text(\n        x=mean_value + (max_value * 0.01),\n        y=ax.get_ylim()[1] * 0.98,\n        s=f'Median: {mean_value_r:,.1f} $/day',\n        color='darkred',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Population label\n    ax.text(\n        0.02,\n        0.98,\n        s=f'Population: {population:,.0f} (M)',\n        transform=ax.transAxes,\n        color='dimgrey',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Add Year label\n    formatted_date = year.strftime('%Y') \n    ax.text(1, 1.06, f'{formatted_date}',\n        transform=ax.transAxes,\n        fontsize=22, ha='right', va='top',\n        fontweight='bold', color='#D3D3D3')\n\n    # Add a custom legend\n    legend_elements = [Line2D([0], [0], color=color, lw=4, label=region, alpha=0.4) for region, color in custom_line.items()]\n    legend = ax.legend(handles=legend_elements, title='Region', title_fontsize='10', fontsize='9', loc='upper right')\n    plt.setp(legend.get_title(), fontweight='bold')\n\n    # Add label \"poorest\" and \"richest\"\n    plt.text(0, -0.065, 'Poorest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkred', ha='left', va='center')\n    plt.text(0.95, -0.065, 'Richest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkblue', va='center')\n\n    # Add Data Source\n    plt.text(0, -0.1, 'Data Source: Gapminder (2024). GDP per capita Dataset.', \n        transform=plt.gca().transAxes, \n        fontsize=8, \n        color='gray')\n\n    # Add Notes\n    plt.text(0, -0.12, 'Notes: The distribution of values, based on GDP per capita, has been calculated using a logarithmic scale ranging from 1 to 10 and adjusted proportionally to the population size of each country.', \n        transform=plt.gca().transAxes,\n        fontsize=8, \n        color='gray')\n\n# Configurate animation\nyears = sorted(df['date'].unique())\nani = animation.FuncAnimation(fig, update, frames=years, repeat=False, interval=50, blit=False)\n\n# Save the animation :)\nani.save('C:/Users/guillem.maya/Downloads/FIG_GDP_Capita_Distribution_PPP_KDEPLOT_GAPMINDER.webp', writer='imagemagick', fps=80)\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202501-distribution-mountains-gdpc/index.html#summary",
    "href": "posts/202501-distribution-mountains-gdpc/index.html#summary",
    "title": "Distribution of Global GDP: Visualizing Income Mountains",
    "section": "",
    "text": "A plot that shows the evolution of Daily Income based on GDP per Capita ($US constant 2017) from 1900 to 2100.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.ticker as ticker\nfrom matplotlib.lines import Line2D\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'iso3'})\n\n# Data Extraction (GAPMINDER)\n# ====================================================================\n# URL Github\nurlgap = 'https://raw.githubusercontent.com/guillemmaya92/world_map/refs/heads/main/gapminder-gdp.csv'\ndfgap = pd.read_csv(urlgap, delimiter=';')\n\n# Transform iso3 to upper and divide population\ndfgap['iso3'] = dfgap['iso3'].str.upper()\ndfgap['pop'] = dfgap['pop'] // 1000000\n\n# Filter years\ndfgap = dfgap[dfgap['year'] &gt; 1900]\n\n# Data Manipulation\n# ====================================================================\n# Copy Dataframe\ndf = dfgap.copy()\n\n# Create a list\ndfs = []\n\n# Interpolate monthly data\nfor iso3 in df['iso3'].unique():\n    temp_df = df[df['iso3'] == iso3].copy()\n    temp_df['date'] = pd.to_datetime(temp_df['year'], format='%Y')\n    temp_df = temp_df[['date', 'pop', 'gdpc']]\n    temp_df = temp_df.set_index('date').resample('ME').mean().interpolate(method='linear').reset_index()\n    temp_df['iso3'] = iso3\n    temp_df['year'] = temp_df['date'].dt.year \n    dfs.append(temp_df)\n\n# Concat dataframes    \ndf = pd.concat(dfs, ignore_index=True)\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='iso3', right_on='iso3')\ndf = df[['iso3', 'Country', 'Region', 'year', 'date', 'pop', 'gdpc']]\ndf = df[df['Region'].notna()]\n\n# Expand dataframe with population\ncolumns = df.columns\ndf = np.repeat(df.values, df['pop'].astype(int), axis=0)\ndf = pd.DataFrame(df, columns=columns)\n\n# Function to create a new distribution\ndef distribution(df):\n    average = df['gdpc'].mean()\n    inequality = np.geomspace(1, 10, len(df))\n    df['gdpcd'] = inequality * (average / np.mean(inequality))\n    \n    return df\n\ndf = df.groupby(['iso3', 'year', 'date']).apply(distribution).reset_index(drop=True)\n\n# Logarithmic distribution\ndf['gdpcdl'] = np.log(df['gdpcd'])\n\n# Logarithmic distribution\ndf['Region'] = np.where(df['iso3'] == 'CHN', 'China', df['Region'])\ndf['Region'] = np.where(df['iso3'] == 'USA', 'USA', df['Region'])\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\n\n# Create a palette\nfig, ax = plt.subplots(figsize=(16, 9))\n\ndef update(year):\n    ax.clear()\n    df_filtered = df[df['date'] == year]\n\n    # Calculate mean value\n    max_value = df_filtered['gdpcdl'].max()\n    mean_value = df_filtered['gdpcdl'].median()\n    mean_value_r = df_filtered['gdpcd'].median() // 365\n    population = len(df_filtered)\n    year = df_filtered['date'].min()\n\n    # Custom palette area\n    custom_area = {\n        'China': '#e3d6b1',\n        'Asia': '#fff3d0',\n        'Europe': '#ccdccd',\n        'Oceania': '#90a8b7',\n        'USA': '#f09c9c',\n        'Americas': '#fdcccc',\n        'Africa': '#ffe3ce'\n    }\n\n    # Custom palette line\n    custom_line = {\n        'China': '#cc9d0e',\n        'Asia': '#FFC107',\n        'Europe': '#004d00',\n        'Oceania': '#003366',\n        'USA': '#a60707',\n        'Americas': '#FF0000',\n        'Africa': '#FF6F00'\n    }\n\n    # Region Order\n    order_region = ['China', 'Asia', 'Africa', 'USA', 'Americas', 'Europe', 'Oceania'] \n\n    # Create kdeplot area and lines\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_area, fill=True, linewidth=1, linestyle='-', ax=ax)\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_line, fill=False, linewidth=1, linestyle='-', ax=ax)\n\n    # Configuration grid and labels\n    ax.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n    ax.text(0, 1.02, 'Evolution by region from 1980 to 2030', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n    ax.set_xlabel('Daily Income PPP ($US constant 2017)', fontsize=10, fontweight='bold')\n    ax.set_ylabel('Frequency of total population', fontsize=10, fontweight='bold')\n    ax.tick_params(axis='x', labelsize=9)\n    ax.tick_params(axis='y', labelsize=9)\n    ax.grid(axis='x')\n    ax.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n    ax.set_ylim(0, 0.4)\n    ax.set_xlim(3, 13)\n\n    # Functions to round axis\n    def round_to_nearest(value, step=0.05):\n        return np.floor(value / step) * step\n    def round_to_nearest_1(value, step=0.25):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_5(value, step=5):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_10(value, step=10):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_50(value, step=50):\n        return int(np.round(value / step) * step)\n\n    # Inverse logarhitmic xticklabels\n    xticks = np.linspace(3, 13, num=12)\n    ax.set_xticks(xticks)\n    ax.set_xticklabels([\n        # Condition 1\n        f'{round_to_nearest(np.exp(tick) / 365) :.2f}' if np.exp(tick) / 365 &lt; 1 else\n        # Condition 2\n        f'{round_to_nearest_1(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 5 else\n        # Condition 3\n        f'{round_to_nearest_5(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 100 else\n        # Condition 4\n        f'{round_to_nearest_10(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 500 else\n        # Condition 5\n        f'{round_to_nearest_50(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 10000 else\n        # Condition 6\n        f'{int(np.exp(tick) / 365)}'\n        for tick in xticks\n    ])\n\n    # Black color to xticklabels\n    for label in ax.get_xticklabels():\n        label.set_color('black')\n        \n    # Median line\n    ax.axvline(mean_value, color='darkred', linestyle='--', linewidth=0.5)\n    ax.text(\n        x=mean_value + (max_value * 0.01),\n        y=ax.get_ylim()[1] * 0.98,\n        s=f'Median: {mean_value_r:,.1f} $/day',\n        color='darkred',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Population label\n    ax.text(\n        0.02,\n        0.98,\n        s=f'Population: {population:,.0f} (M)',\n        transform=ax.transAxes,\n        color='dimgrey',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Add Year label\n    formatted_date = year.strftime('%Y') \n    ax.text(1, 1.06, f'{formatted_date}',\n        transform=ax.transAxes,\n        fontsize=22, ha='right', va='top',\n        fontweight='bold', color='#D3D3D3')\n\n    # Add a custom legend\n    legend_elements = [Line2D([0], [0], color=color, lw=4, label=region, alpha=0.4) for region, color in custom_line.items()]\n    legend = ax.legend(handles=legend_elements, title='Region', title_fontsize='10', fontsize='9', loc='upper right')\n    plt.setp(legend.get_title(), fontweight='bold')\n\n    # Add label \"poorest\" and \"richest\"\n    plt.text(0, -0.065, 'Poorest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkred', ha='left', va='center')\n    plt.text(0.95, -0.065, 'Richest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkblue', va='center')\n\n    # Add Data Source\n    plt.text(0, -0.1, 'Data Source: Gapminder (2024). GDP per capita Dataset.', \n        transform=plt.gca().transAxes, \n        fontsize=8, \n        color='gray')\n\n    # Add Notes\n    plt.text(0, -0.12, 'Notes: The distribution of values, based on GDP per capita, has been calculated using a logarithmic scale ranging from 1 to 10 and adjusted proportionally to the population size of each country.', \n        transform=plt.gca().transAxes,\n        fontsize=8, \n        color='gray')\n\n# Configurate animation\nyears = sorted(df['date'].unique())\nani = animation.FuncAnimation(fig, update, frames=years, repeat=False, interval=50, blit=False)\n\n# Save the animation :)\nani.save('C:/Users/guillem.maya/Downloads/FIG_GDP_Capita_Distribution_PPP_KDEPLOT_GAPMINDER.webp', writer='imagemagick', fps=80)\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202503-bitcoin-distribution/index.html",
    "href": "posts/202503-bitcoin-distribution/index.html",
    "title": "Bitcoin Wealth Distribution: Utopian vision of narcocapitalism",
    "section": "",
    "text": "A plot that shows the distribution wealth of Bitcoin among the wallets with a balance greater than $5,000 USD.\n\n\nCode\n# Libraries\n# ===================================================\nimport pandas as pd\nimport numpy as np\nfrom bs4 import BeautifulSoup\nimport requests\nfrom io import StringIO\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport matplotlib.patches as patches\n\n# Bitcoin Price\n# ===================================================\nurl = \"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\"\nresponse = requests.get(url)\ndata = response.json()\nbtcprice = data.get(\"USD\")\n\n# Bitcoin Supply\n# ===================================================\ndef get_btc_supply():\n    response = requests.get(\"https://blockchain.info/q/totalbc\")\n    satoshi = int(response.text)\n    btcsupply = satoshi / 100000000\n    return btcsupply\nbtcsupply = get_btc_supply()\n\n# Data Extraction\n# ===================================================\nurl = \"https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html\"\nsoup = BeautifulSoup(requests.get(url).text, \"html.parser\")\ntable = soup.find(\"table\", {\"class\": \"table table-condensed bb\"})\ndf = pd.read_html(StringIO(str(table)))[0]\n\n# Data Transformation\n# ===================================================\n# Select columns\ndf = df[['Balance, BTC', 'Addresses', 'BTC']]\n\n# Rename columns and add average\ndf.rename(columns={'Addresses': 'rows', 'BTC': 'btc'}, inplace=True)\n\n# Extract start and end range\ndf['start'] = df['Balance, BTC'].str.extract(r'[\\[\\(](\\d[\\d,\\.]*)')\ndf['end'] = df['Balance, BTC'].str.extract(r'-\\s([\\d,\\.]+)\\)')\ndf['btc'] = df['btc'].str.extract('([0-9.]+)')\n\n# Convert to values\ndf['rows'] = df['rows'].replace({',': ''}, regex=True).astype(int)\ndf['start'] = df['start'].replace({',': ''}, regex=True).astype(float)\ndf['end'] = df['end'].replace({',': ''}, regex=True).astype(float)\ndf['btc'] = df['btc'].replace({',': ''}, regex=True).astype(float)\n\n# Add average price\ndf['average'] = df['btc'] / df['rows']\n\n# Select columns\ndf = df[['rows', 'start', 'end', 'btc', 'average']]\n\n# Change first and last value\ndf.loc[df.index[0], 'start'] = 0.000001\ndf.loc[df.index[-1], 'end'] = 250000\n\n# Create a list\nresult = []\n\n# Iterate over each row \nfor index, row in df.iterrows():\n    n = int(row['rows'])\n    start = row['start']\n    end = row['end']\n    average = row['average']\n    \n    # Generate a distribution\n    valores = np.logspace(np.log(start) / np.log(12), np.log(end) / np.log(12), n)\n        \n   # Calcular el factor de escala para ajustar el promedio\n    current_average = np.mean(valores)\n    scale_factor = average / current_average\n    adjusted_values = valores * scale_factor\n\n    # Add values to result list\n    result.extend(valores)\n\n# Crear a dataframe with all values\ndf = pd.DataFrame(result, columns=['btc'])\n\n# Calculate marketcap\nmarketcap = btcsupply * btcprice\n\n# USD Value, Filter &gt;5000 and count\ndf['usd'] = df['btc'] * btcprice\ndf = df[df['usd'] &gt; 5000]\ndf['count'] = 1\n\n# Grouping by 100 percentiles\ndf['percentile'] = pd.qcut(df['btc'], 100, labels=False) + 1\n\n# Grouping by 10 percentiles\ndf['percentile2'] = pd.cut(\n    df['percentile'], \n    bins=range(1, 111, 10), \n    right=False, \n    labels=[i + 9 for i in range(1, 101, 10)]\n).astype(int)\n\n# Calculate GINI Index\ndef gini(x):\n    x = np.array(x)\n    x = np.sort(x)\n    n = len(x)\n    gini_index = (2 * np.sum(np.arange(1, n + 1) * x) - (n + 1) * np.sum(x)) / (n * np.sum(x))\n    return gini_index\ngini_value = gini(df['usd'])\n\n# Summarizing data \ndf = df.groupby(['percentile', 'percentile2'])[['usd', 'btc', 'count']].sum().reset_index()\n\n# Average price\ndf['average_usd'] = df['usd'] / df['count']\ndf['percentage'] = df['usd'] / df['usd'].sum()\n\n# Select columns\ndf = df[['percentile', 'percentile2', 'usd', 'count', 'average_usd', 'percentage']]\n\n# Define palette\ncolor_palette = {\n    10: \"#050407\",\n    20: \"#07111e\",\n    30: \"#15334b\",\n    40: \"#2b5778\",\n    50: \"#417da1\",\n    60: \"#5593bb\",\n    70: \"#5a7aa3\",\n    80: \"#6d5e86\",\n    90: \"#a2425c\",\n    100: \"#D21E00\"\n}\n\n# Map palette color\ndf['color'] = df['percentile2'].map(color_palette)\n\n# Percentiles dataframe 2\ndf2 = df.copy()\ndf2 = df2.groupby(['percentile2', 'color'], as_index=False)[['usd', 'count']].sum()\ndf2['average_usd'] = df2['usd'] / df2['count']\ndf2['percentage'] = df2['usd'] / (df2['usd']).sum()\ndf2['count'] = 10\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create the figure and suplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [10, 0.5]})\n\n# First Plot\n# ==================\n# Plot Bars\nbars = ax1.bar(df['percentile'], df['average_usd'], color=df['color'], edgecolor='darkgrey', linewidth=0.5, zorder=2)\n\n# Title and labels\nax1.text(0, 1.1, 'Bitcoin Wealth Distribution', fontsize=13, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.06, 'Intrapercentile Analysis of Wealth Concentration (excluding &lt; 5000$ wallets)', fontsize=9, color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlabel('% Wallets', fontsize=10, weight='bold')\nax1.set_ylabel('Wealth ($)', fontsize=10, weight='bold')\n\n# Configuration\nax1.grid(axis='x', linestyle='-', alpha=0.5, zorder=1)\nax1.set_xlim(0, 101)\nax1.set_ylim(0, 2000000)\nax1.set_xticks(np.arange(0, 101, step=10))\nax1.set_yticks(np.arange(0, 2000001, step=250000))\nax1.tick_params(axis='x', labelsize=10)\nax1.tick_params(axis='y', labelsize=10)\nax1.spines['top'].set_visible(False)\nax1.spines['right'].set_visible(False)\n\n# Function to format Y axis\ndef format_func(value, tick_number):\n    if value &gt;= 1e6:\n        return '{:,.1f}M'.format(value / 1e6)\n    else:\n        return '{:,.0f}K'.format(value / 1e3)\n\n# Formatting x and y axis\nax1.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{x:.0f}%'))\nax1.yaxis.set_major_formatter(FuncFormatter(format_func))\n\n# Lines and area to separate outliers\nax1.axhline(y=1850000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.axhline(y=1800000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.add_patch(patches.Rectangle((0, 1800000), 105, 50000, linewidth=0, edgecolor='none', facecolor='white', zorder=3))\n\n# Y Axis modify the outlier value\nlabels = [item.get_text() for item in ax1.get_yticklabels()]\nlabels[-1] = '17M'\nax1.set_yticklabels(labels)\n\n# Show labels each 10 percentile\nfor i, (bar, value) in enumerate(zip(bars, df['average_usd'])):\n    value_rounded = round(value / 5000) * 5000\n    if i % 10 == 0:\n        ax1.text(bar.get_x() + bar.get_width() / 2, \n                 abs(bar.get_height()) * 1.4 + 50000,\n                 f'{value_rounded:,.0f}',\n                 ha='center', \n                 va='bottom', \n                 fontsize=8.5,\n                 color='#2c2c2c', \n                 rotation=90)\n\n# Show GINI Index\nax1.text(\n    0.09, 0.97, f\"Gini Index: {gini_value:.2f}\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='right',\n    va='top', \n    bbox=dict(boxstyle=\"round,pad=0.3\", edgecolor='gray', facecolor='white')\n)\n\n# Show MarketCap\nax1.text(\n    0.05, 0.88, \n    f\"Price: ${btcprice / 1e3:.0f} k\\nMCap: ${marketcap / 1e12:.2f} Bn\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='center',\n    va='top'\n)\n\n# Second Plot\n# ==================\n# Plot Bars\nax2.barh([0] * len(df2), df2['count'], left=df2['percentile2'] - df2['count'], color=df2['color'])\n\n# Configuration\nax2.grid(axis='x', linestyle='-', color='white', alpha=1, linewidth=0.5)\nax2.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False)\nax2.tick_params(axis='y', which='both', left=False, right=False, labelleft=False)\nax2.spines['top'].set_visible(False)\nax2.spines['right'].set_visible(False)\nax2.spines['left'].set_visible(False)\nax2.spines['bottom'].set_visible(False)\nx_ticks = np.linspace(df2['percentile2'].min(), df2['percentile2'].max(), 10)\nax2.set_xticks(x_ticks)\nax2.set_xlim(0, 101)\n\n# Add label values\nfor i, row in df2.iterrows():\n    plt.text(row['percentile2'] - row['count'] + row['count'] / 2, 0, \n             f'{row[\"percentage\"] * 100:.2f}%', ha='center', va='center', color='white', fontweight='bold')\n    \n # Add Year label\nformatted_date = 2024 \nax1.text(1, 1.1, f'{formatted_date}',\n    transform=ax1.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nax2.text(0, -0.5, 'Data Source: BitInfoCharts. \"Top 100 Richest Bitcoin Addresses.\"',\n         transform=ax2.transAxes,\n         fontsize=8,\n         color='#2c2c2c')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\nplt.savefig(\"C:/Users/guill/Downloads/FIG_BITINFO_Bitcoin_Wealth_Distribution.png\", dpi=300, bbox_inches='tight') \n\n# Plot it!\nplt.show()"
  },
  {
    "objectID": "posts/202503-bitcoin-distribution/index.html#summary",
    "href": "posts/202503-bitcoin-distribution/index.html#summary",
    "title": "Bitcoin Wealth Distribution: Utopian vision of narcocapitalism",
    "section": "",
    "text": "A plot that shows the distribution wealth of Bitcoin among the wallets with a balance greater than $5,000 USD.\n\n\nCode\n# Libraries\n# ===================================================\nimport pandas as pd\nimport numpy as np\nfrom bs4 import BeautifulSoup\nimport requests\nfrom io import StringIO\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport matplotlib.patches as patches\n\n# Bitcoin Price\n# ===================================================\nurl = \"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\"\nresponse = requests.get(url)\ndata = response.json()\nbtcprice = data.get(\"USD\")\n\n# Bitcoin Supply\n# ===================================================\ndef get_btc_supply():\n    response = requests.get(\"https://blockchain.info/q/totalbc\")\n    satoshi = int(response.text)\n    btcsupply = satoshi / 100000000\n    return btcsupply\nbtcsupply = get_btc_supply()\n\n# Data Extraction\n# ===================================================\nurl = \"https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html\"\nsoup = BeautifulSoup(requests.get(url).text, \"html.parser\")\ntable = soup.find(\"table\", {\"class\": \"table table-condensed bb\"})\ndf = pd.read_html(StringIO(str(table)))[0]\n\n# Data Transformation\n# ===================================================\n# Select columns\ndf = df[['Balance, BTC', 'Addresses', 'BTC']]\n\n# Rename columns and add average\ndf.rename(columns={'Addresses': 'rows', 'BTC': 'btc'}, inplace=True)\n\n# Extract start and end range\ndf['start'] = df['Balance, BTC'].str.extract(r'[\\[\\(](\\d[\\d,\\.]*)')\ndf['end'] = df['Balance, BTC'].str.extract(r'-\\s([\\d,\\.]+)\\)')\ndf['btc'] = df['btc'].str.extract('([0-9.]+)')\n\n# Convert to values\ndf['rows'] = df['rows'].replace({',': ''}, regex=True).astype(int)\ndf['start'] = df['start'].replace({',': ''}, regex=True).astype(float)\ndf['end'] = df['end'].replace({',': ''}, regex=True).astype(float)\ndf['btc'] = df['btc'].replace({',': ''}, regex=True).astype(float)\n\n# Add average price\ndf['average'] = df['btc'] / df['rows']\n\n# Select columns\ndf = df[['rows', 'start', 'end', 'btc', 'average']]\n\n# Change first and last value\ndf.loc[df.index[0], 'start'] = 0.000001\ndf.loc[df.index[-1], 'end'] = 250000\n\n# Create a list\nresult = []\n\n# Iterate over each row \nfor index, row in df.iterrows():\n    n = int(row['rows'])\n    start = row['start']\n    end = row['end']\n    average = row['average']\n    \n    # Generate a distribution\n    valores = np.logspace(np.log(start) / np.log(12), np.log(end) / np.log(12), n)\n        \n   # Calcular el factor de escala para ajustar el promedio\n    current_average = np.mean(valores)\n    scale_factor = average / current_average\n    adjusted_values = valores * scale_factor\n\n    # Add values to result list\n    result.extend(valores)\n\n# Crear a dataframe with all values\ndf = pd.DataFrame(result, columns=['btc'])\n\n# Calculate marketcap\nmarketcap = btcsupply * btcprice\n\n# USD Value, Filter &gt;5000 and count\ndf['usd'] = df['btc'] * btcprice\ndf = df[df['usd'] &gt; 5000]\ndf['count'] = 1\n\n# Grouping by 100 percentiles\ndf['percentile'] = pd.qcut(df['btc'], 100, labels=False) + 1\n\n# Grouping by 10 percentiles\ndf['percentile2'] = pd.cut(\n    df['percentile'], \n    bins=range(1, 111, 10), \n    right=False, \n    labels=[i + 9 for i in range(1, 101, 10)]\n).astype(int)\n\n# Calculate GINI Index\ndef gini(x):\n    x = np.array(x)\n    x = np.sort(x)\n    n = len(x)\n    gini_index = (2 * np.sum(np.arange(1, n + 1) * x) - (n + 1) * np.sum(x)) / (n * np.sum(x))\n    return gini_index\ngini_value = gini(df['usd'])\n\n# Summarizing data \ndf = df.groupby(['percentile', 'percentile2'])[['usd', 'btc', 'count']].sum().reset_index()\n\n# Average price\ndf['average_usd'] = df['usd'] / df['count']\ndf['percentage'] = df['usd'] / df['usd'].sum()\n\n# Select columns\ndf = df[['percentile', 'percentile2', 'usd', 'count', 'average_usd', 'percentage']]\n\n# Define palette\ncolor_palette = {\n    10: \"#050407\",\n    20: \"#07111e\",\n    30: \"#15334b\",\n    40: \"#2b5778\",\n    50: \"#417da1\",\n    60: \"#5593bb\",\n    70: \"#5a7aa3\",\n    80: \"#6d5e86\",\n    90: \"#a2425c\",\n    100: \"#D21E00\"\n}\n\n# Map palette color\ndf['color'] = df['percentile2'].map(color_palette)\n\n# Percentiles dataframe 2\ndf2 = df.copy()\ndf2 = df2.groupby(['percentile2', 'color'], as_index=False)[['usd', 'count']].sum()\ndf2['average_usd'] = df2['usd'] / df2['count']\ndf2['percentage'] = df2['usd'] / (df2['usd']).sum()\ndf2['count'] = 10\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create the figure and suplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [10, 0.5]})\n\n# First Plot\n# ==================\n# Plot Bars\nbars = ax1.bar(df['percentile'], df['average_usd'], color=df['color'], edgecolor='darkgrey', linewidth=0.5, zorder=2)\n\n# Title and labels\nax1.text(0, 1.1, 'Bitcoin Wealth Distribution', fontsize=13, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.06, 'Intrapercentile Analysis of Wealth Concentration (excluding &lt; 5000$ wallets)', fontsize=9, color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlabel('% Wallets', fontsize=10, weight='bold')\nax1.set_ylabel('Wealth ($)', fontsize=10, weight='bold')\n\n# Configuration\nax1.grid(axis='x', linestyle='-', alpha=0.5, zorder=1)\nax1.set_xlim(0, 101)\nax1.set_ylim(0, 2000000)\nax1.set_xticks(np.arange(0, 101, step=10))\nax1.set_yticks(np.arange(0, 2000001, step=250000))\nax1.tick_params(axis='x', labelsize=10)\nax1.tick_params(axis='y', labelsize=10)\nax1.spines['top'].set_visible(False)\nax1.spines['right'].set_visible(False)\n\n# Function to format Y axis\ndef format_func(value, tick_number):\n    if value &gt;= 1e6:\n        return '{:,.1f}M'.format(value / 1e6)\n    else:\n        return '{:,.0f}K'.format(value / 1e3)\n\n# Formatting x and y axis\nax1.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{x:.0f}%'))\nax1.yaxis.set_major_formatter(FuncFormatter(format_func))\n\n# Lines and area to separate outliers\nax1.axhline(y=1850000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.axhline(y=1800000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.add_patch(patches.Rectangle((0, 1800000), 105, 50000, linewidth=0, edgecolor='none', facecolor='white', zorder=3))\n\n# Y Axis modify the outlier value\nlabels = [item.get_text() for item in ax1.get_yticklabels()]\nlabels[-1] = '17M'\nax1.set_yticklabels(labels)\n\n# Show labels each 10 percentile\nfor i, (bar, value) in enumerate(zip(bars, df['average_usd'])):\n    value_rounded = round(value / 5000) * 5000\n    if i % 10 == 0:\n        ax1.text(bar.get_x() + bar.get_width() / 2, \n                 abs(bar.get_height()) * 1.4 + 50000,\n                 f'{value_rounded:,.0f}',\n                 ha='center', \n                 va='bottom', \n                 fontsize=8.5,\n                 color='#2c2c2c', \n                 rotation=90)\n\n# Show GINI Index\nax1.text(\n    0.09, 0.97, f\"Gini Index: {gini_value:.2f}\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='right',\n    va='top', \n    bbox=dict(boxstyle=\"round,pad=0.3\", edgecolor='gray', facecolor='white')\n)\n\n# Show MarketCap\nax1.text(\n    0.05, 0.88, \n    f\"Price: ${btcprice / 1e3:.0f} k\\nMCap: ${marketcap / 1e12:.2f} Bn\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='center',\n    va='top'\n)\n\n# Second Plot\n# ==================\n# Plot Bars\nax2.barh([0] * len(df2), df2['count'], left=df2['percentile2'] - df2['count'], color=df2['color'])\n\n# Configuration\nax2.grid(axis='x', linestyle='-', color='white', alpha=1, linewidth=0.5)\nax2.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False)\nax2.tick_params(axis='y', which='both', left=False, right=False, labelleft=False)\nax2.spines['top'].set_visible(False)\nax2.spines['right'].set_visible(False)\nax2.spines['left'].set_visible(False)\nax2.spines['bottom'].set_visible(False)\nx_ticks = np.linspace(df2['percentile2'].min(), df2['percentile2'].max(), 10)\nax2.set_xticks(x_ticks)\nax2.set_xlim(0, 101)\n\n# Add label values\nfor i, row in df2.iterrows():\n    plt.text(row['percentile2'] - row['count'] + row['count'] / 2, 0, \n             f'{row[\"percentage\"] * 100:.2f}%', ha='center', va='center', color='white', fontweight='bold')\n    \n # Add Year label\nformatted_date = 2024 \nax1.text(1, 1.1, f'{formatted_date}',\n    transform=ax1.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nax2.text(0, -0.5, 'Data Source: BitInfoCharts. \"Top 100 Richest Bitcoin Addresses.\"',\n         transform=ax2.transAxes,\n         fontsize=8,\n         color='#2c2c2c')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\nplt.savefig(\"C:/Users/guill/Downloads/FIG_BITINFO_Bitcoin_Wealth_Distribution.png\", dpi=300, bbox_inches='tight') \n\n# Plot it!\nplt.show()"
  },
  {
    "objectID": "posts/202504-idealista-prices/index.html",
    "href": "posts/202504-idealista-prices/index.html",
    "title": "Alquiler de vivienda en Catalunya: Distribución de precios",
    "section": "",
    "text": "Representación de los precios de aquiler por comarca.\n\n\nCode\n# Libraries\n# ===================================\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggdist)\nlibrary(ggtext)\nlibrary(scales)\nlibrary(grid)\n\n# Extract Data\n# ===================================\n# URL GitHub\nurl &lt;- \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/Catalunya_CP.csv\"\n\n# Read CSV\ndf &lt;- read_delim(url, delim = \";\", locale = locale(encoding = \"latin1\"))\n\n# Select relevant columns and filter data\ndf &lt;- df %&gt;%\n  select(province, region, price) %&gt;%\n  filter(region %in% c(\"Barcelonès\") & price &lt; 3000) %&gt;%\n  filter(!is.na(price))\n\n# Transform Data\n# ===================================\n# Define values\nmin_price &lt;- 0\ncheaper_price &lt;- 800\nmedian_price &lt;- median(df$price, na.rm = TRUE)\nmax_price &lt;- 3000\ntotal_announcements &lt;- nrow(df)\n\n# Calculate extra label values\nmid1 &lt;- (cheaper_price + min_price) / 2\nannouncements1 &lt;- nrow(df %&gt;% filter(price &gt; min_price & price &lt;= cheaper_price))\nmid2 &lt;- (median_price + cheaper_price) / 2\nannouncements2 &lt;- nrow(df %&gt;% filter(price &gt; cheaper_price & price &lt;= median_price))\nmid3 &lt;- (max_price + median_price) / 2\nannouncements3 &lt;- nrow(df %&gt;% filter(price &gt; median_price & price &lt;= max_price))\n\n# Add color column\ndf &lt;- df %&gt;%\n  mutate(color = case_when(\n    price &lt; cheaper_price ~ \"#ffc939\",\n    price &lt; median_price ~ \"#a8c2d2\",\n    TRUE ~ \"#477794\"\n  ))\n\n# Show data\nprint(head(df))\n\n# Plot Data\n# ===================================\ngg &lt;- df %&gt;%\n  # Create ggplot\n  ggplot(aes(x = price, fill = after_stat(case_when(\n    x &lt;= cheaper_price ~ \"cheaper\",\n    x &lt;= median_price ~ \"median\",\n    TRUE ~ \"expensive\"\n  )))) +\n  # Define type of plot\n  geom_dots(\n    smooth = smooth_bounded(adjust = 0.6), \n    side = \"both\", \n    color = NA,\n    dotsize = 0.8,\n    stackratio = 1.3\n  ) +\n  # Configure XY Axis\n  scale_x_continuous(\n    limits = c(min_price, max_price),\n    breaks = seq(min_price, max_price, by = 200),\n    labels = scales::comma_format()\n  ) +\n  scale_y_continuous(breaks = NULL) +\n  # Configure Titles and Captions\n  labs(\n    title = 'Pisos ofertados en Idealista por menos de 3.000 euros',\n    subtitle = \"Anuncios en la comarca del Barcelonés\",\n    x = \"Precio (€)\",\n    caption = paste0(\n      \"**Fuente**: Idealista&lt;br&gt;\n      **Notas**: Cada bola representa un anuncio\"\n    )\n  ) +\n  # Configure elements theme\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    plot.subtitle = element_text(size = 12, face = \"plain\"),\n    axis.title.x = element_text(size = 9, face = \"bold\"),\n    axis.title.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    legend.position = \"none\",\n    plot.caption = element_markdown(size = 8, hjust = 0)\n  ) +\n # Configure fill colors after_stats\n  scale_fill_manual(values = c(\n    \"cheaper\" = \"#ffc939\",\n    \"median\" = \"#a8c2d2\",\n    \"expensive\" = \"#477794\"\n  )) +\n  # Plot Vertical And Horizontal lines\n  geom_hline(yintercept = 0, linetype = \"solid\", color = \"grey\", size = 0.5) +\n  geom_vline(xintercept = cheaper_price, color = \"#9c7a1f\", linetype = \"dotted\", size = 0.25) +\n  geom_vline(xintercept = median_price, color = \"#477794\", linetype = \"dotted\", size = 0.25) +\n  # Annotate: City and adds \n  annotate(\"text\", \n           x = 0, \n           y = 0.05, \n           label = \"Barcelonés\", \n           size = 4, \n           color = \"black\", \n           fontface = \"bold\", \n           hjust = 0) +\n  annotate(\"text\", \n           x = 0, \n           y = -0.08, \n           label = paste(\"Total anuncios:\\n\", comma(total_announcements)), \n           size = 3.5, \n           color = \"black\", \n           fontface = \"plain\", \n           hjust = 0) +\n  # Annotate G1: Cheap adds\n  annotate(geom = \"label\", \n           x = mid1, \n           y = 0.8, \n           label = paste(comma(announcements1), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"#a68221\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid1, \n           y = 0.73, \n           label = paste(\"Entre\", comma(min_price), \"y\", comma(cheaper_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Annotate G2: Median adds\n  annotate(geom = \"label\", \n           x = mid2, \n           y = 0.8, \n           label = paste(comma(announcements2), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"grey\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid2, \n           y = 0.73, \n           label = paste(\"Entre\", comma(cheaper_price), \"y\", comma(median_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Annotate G3: Expensive adds\n  annotate(geom = \"label\", \n           x = mid3, \n           y = 0.8, \n           label = paste(comma(announcements3), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"#477794\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid3, \n           y = 0.73, \n           label = paste(\"Entre\", comma(median_price), \"y\", comma(max_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Extra Annotation: @Author\n  annotation_custom(\n    grob = textGrob(\"@damnedliestats\", gp = gpar(fontsize = 8, col = \"black\")), \n    xmin = 2600, xmax = 3000, ymin = -0.73, ymax = -0.73\n  ) +\n  # Allow extra elements\n  coord_cartesian(clip = \"off\")\n\n# Saving Plot\nggsave(\"C:/Users/guill/Downloads/Barcelonés.jpeg\", \n       plot = gg, dpi = 300, width = 10, height = 6)"
  },
  {
    "objectID": "posts/202504-idealista-prices/index.html#summary",
    "href": "posts/202504-idealista-prices/index.html#summary",
    "title": "Alquiler de vivienda en Catalunya: Distribución de precios",
    "section": "",
    "text": "Representación de los precios de aquiler por comarca.\n\n\nCode\n# Libraries\n# ===================================\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggdist)\nlibrary(ggtext)\nlibrary(scales)\nlibrary(grid)\n\n# Extract Data\n# ===================================\n# URL GitHub\nurl &lt;- \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/Catalunya_CP.csv\"\n\n# Read CSV\ndf &lt;- read_delim(url, delim = \";\", locale = locale(encoding = \"latin1\"))\n\n# Select relevant columns and filter data\ndf &lt;- df %&gt;%\n  select(province, region, price) %&gt;%\n  filter(region %in% c(\"Barcelonès\") & price &lt; 3000) %&gt;%\n  filter(!is.na(price))\n\n# Transform Data\n# ===================================\n# Define values\nmin_price &lt;- 0\ncheaper_price &lt;- 800\nmedian_price &lt;- median(df$price, na.rm = TRUE)\nmax_price &lt;- 3000\ntotal_announcements &lt;- nrow(df)\n\n# Calculate extra label values\nmid1 &lt;- (cheaper_price + min_price) / 2\nannouncements1 &lt;- nrow(df %&gt;% filter(price &gt; min_price & price &lt;= cheaper_price))\nmid2 &lt;- (median_price + cheaper_price) / 2\nannouncements2 &lt;- nrow(df %&gt;% filter(price &gt; cheaper_price & price &lt;= median_price))\nmid3 &lt;- (max_price + median_price) / 2\nannouncements3 &lt;- nrow(df %&gt;% filter(price &gt; median_price & price &lt;= max_price))\n\n# Add color column\ndf &lt;- df %&gt;%\n  mutate(color = case_when(\n    price &lt; cheaper_price ~ \"#ffc939\",\n    price &lt; median_price ~ \"#a8c2d2\",\n    TRUE ~ \"#477794\"\n  ))\n\n# Show data\nprint(head(df))\n\n# Plot Data\n# ===================================\ngg &lt;- df %&gt;%\n  # Create ggplot\n  ggplot(aes(x = price, fill = after_stat(case_when(\n    x &lt;= cheaper_price ~ \"cheaper\",\n    x &lt;= median_price ~ \"median\",\n    TRUE ~ \"expensive\"\n  )))) +\n  # Define type of plot\n  geom_dots(\n    smooth = smooth_bounded(adjust = 0.6), \n    side = \"both\", \n    color = NA,\n    dotsize = 0.8,\n    stackratio = 1.3\n  ) +\n  # Configure XY Axis\n  scale_x_continuous(\n    limits = c(min_price, max_price),\n    breaks = seq(min_price, max_price, by = 200),\n    labels = scales::comma_format()\n  ) +\n  scale_y_continuous(breaks = NULL) +\n  # Configure Titles and Captions\n  labs(\n    title = 'Pisos ofertados en Idealista por menos de 3.000 euros',\n    subtitle = \"Anuncios en la comarca del Barcelonés\",\n    x = \"Precio (€)\",\n    caption = paste0(\n      \"**Fuente**: Idealista&lt;br&gt;\n      **Notas**: Cada bola representa un anuncio\"\n    )\n  ) +\n  # Configure elements theme\n  theme_minimal() +\n  theme(\n    plot.title = element_text(size = 16, face = \"bold\"),\n    plot.subtitle = element_text(size = 12, face = \"plain\"),\n    axis.title.x = element_text(size = 9, face = \"bold\"),\n    axis.title.y = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(),\n    legend.position = \"none\",\n    plot.caption = element_markdown(size = 8, hjust = 0)\n  ) +\n # Configure fill colors after_stats\n  scale_fill_manual(values = c(\n    \"cheaper\" = \"#ffc939\",\n    \"median\" = \"#a8c2d2\",\n    \"expensive\" = \"#477794\"\n  )) +\n  # Plot Vertical And Horizontal lines\n  geom_hline(yintercept = 0, linetype = \"solid\", color = \"grey\", size = 0.5) +\n  geom_vline(xintercept = cheaper_price, color = \"#9c7a1f\", linetype = \"dotted\", size = 0.25) +\n  geom_vline(xintercept = median_price, color = \"#477794\", linetype = \"dotted\", size = 0.25) +\n  # Annotate: City and adds \n  annotate(\"text\", \n           x = 0, \n           y = 0.05, \n           label = \"Barcelonés\", \n           size = 4, \n           color = \"black\", \n           fontface = \"bold\", \n           hjust = 0) +\n  annotate(\"text\", \n           x = 0, \n           y = -0.08, \n           label = paste(\"Total anuncios:\\n\", comma(total_announcements)), \n           size = 3.5, \n           color = \"black\", \n           fontface = \"plain\", \n           hjust = 0) +\n  # Annotate G1: Cheap adds\n  annotate(geom = \"label\", \n           x = mid1, \n           y = 0.8, \n           label = paste(comma(announcements1), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"#a68221\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid1, \n           y = 0.73, \n           label = paste(\"Entre\", comma(min_price), \"y\", comma(cheaper_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Annotate G2: Median adds\n  annotate(geom = \"label\", \n           x = mid2, \n           y = 0.8, \n           label = paste(comma(announcements2), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"grey\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid2, \n           y = 0.73, \n           label = paste(\"Entre\", comma(cheaper_price), \"y\", comma(median_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Annotate G3: Expensive adds\n  annotate(geom = \"label\", \n           x = mid3, \n           y = 0.8, \n           label = paste(comma(announcements3), \"pisos\"), \n           size = 4, \n           color = \"black\", \n           fontface = \"plain\",\n           fill = \"#477794\",\n           alpha = 0.3,\n           label.size = 0) +\n  annotate(geom = \"text\", \n           x = mid3, \n           y = 0.73, \n           label = paste(\"Entre\", comma(median_price), \"y\", comma(max_price), \"(€)\"), \n           size = 3, \n           color = \"#909090\") +\n  # Extra Annotation: @Author\n  annotation_custom(\n    grob = textGrob(\"@damnedliestats\", gp = gpar(fontsize = 8, col = \"black\")), \n    xmin = 2600, xmax = 3000, ymin = -0.73, ymax = -0.73\n  ) +\n  # Allow extra elements\n  coord_cartesian(clip = \"off\")\n\n# Saving Plot\nggsave(\"C:/Users/guill/Downloads/Barcelonés.jpeg\", \n       plot = gg, dpi = 300, width = 10, height = 6)"
  },
  {
    "objectID": "posts/202505-lorenz-curves/index.html",
    "href": "posts/202505-lorenz-curves/index.html",
    "title": "Lorenz Curves: A global and national perspectives",
    "section": "",
    "text": "This is a global graphical representation of income and wealth for the years 1995 and 2021. Illustrating the dynamics of inequality by comparing Gini indices through Lorenz curves, both within (intra-country) and between (inter-country) nations.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\nimport matplotlib.patheffects as patheffects\n\n# Parameters\n# =====================================================================\n# Select between Income/Wealth\nselection = 'Income'\nyear = 2021\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction (Percentages)\n# ===================================================\n# URL GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/WID_Percentiles.parquet\"\n\n# Extract data from parquet\ndf = pd.read_parquet(url, engine='pyarrow')\n\n# Filter year\ndf = df[df['year'] == year]\n\n# Data Extraction (Values)\n# ===================================================\n# URL GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/WID_Values.parquet\"\n\n# Extract data from parquet\ndfv = pd.read_parquet(url, engine='pyarrow')\n\n# Filter year\ndfv = dfv[dfv['year'] == year]\n\n# Extract world values\ngincomew = dfv.loc[dfv['country'] == 'WO', 'gincome'].iloc[0]\ngwealthw = dfv.loc[dfv['country'] == 'WO', 'gwealth'].iloc[0]\n\n# Extract countries weighted average values\ndfincome = dfv[dfv['country'].isin(df_countries['ISO2']) & dfv['gincome'].notnull() & dfv['population'].notnull()]\ndfwealth = dfv[dfv['country'].isin(df_countries['ISO2']) & dfv['gwealth'].notnull() & dfv['population'].notnull()]\n\ngincomec = np.average(dfincome['gincome'], weights= dfincome['population'])\ngwealthc = np.average(dfwealth['gwealth'], weights= dfwealth['population'])\n\n# Dynamic value\nginiw = round(gwealthw, 2) if selection == 'Wealth' else round(gincomew, 2)\nginic= round(gwealthc, 2) if selection == 'Wealth' else round(gincomec, 2)\n\n# Data Manipulation\n# ===================================================\n# Calculate cummulative\ndf['percentile'] =  df['percentile'] / 100\ndf['income'] =  df['income'] / 100\ndf['wealth'] =  df['wealth'] / 100\ndf['income_cum'] =  df.groupby(['country'])['income'].cumsum() / df.groupby(['country'])['income'].transform('sum')\ndf['wealth_cum'] =  df.groupby(['country'])['wealth'].cumsum() / df.groupby(['country'])['wealth'].transform('sum')\ndf['value_cum'] = df['income_cum'] if selection == 'Income' else df['wealth_cum']\n\n# Countries\ndfc = df.merge(df_countries, how='left', left_on='country', right_on='ISO2')\ndfc = dfc[dfc['Region'].notna()]\ndfc = dfc[['country', 'percentile', 'value_cum']]\n\n# World\ndfw = df[df['country'] == \"WO\"]\ndfw = dfw[['country', 'percentile', 'value_cum']]\ndfw['country'] = 'Inter-Countries'\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\nplt.figure(figsize=(10, 10))\n\n# Basic Grey Plot Lines\nsns.lineplot(\n    data=dfc, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=0.4,\n    alpha=0.5,\n    palette=['#808080']\n).legend_.remove()\n\n# Black Shadow Plot Lines\nsns.lineplot(\n    data=dfw, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=2.25,\n    alpha=1,\n    palette=['black']\n).legend_.remove()\n\n# Color Plot Lines\nsns.lineplot(\n    data=dfw, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=1.5,\n    alpha=1,\n    palette=['#FF0000']\n).legend_.remove()\n\n# Add Inequality lines\nplt.plot([0, 1], [0, 1], color=\"gray\", linestyle=\"-\", linewidth=1)\n\n# Configuración del gráfico\nplt.text(0, 1.05, f'Global {selection} Distribution', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.02, 'A global and national perspective on Lorenz curves', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlabel('Cumulative Population (%)', fontsize=10, fontweight='bold')\nplt.ylabel(f'Cumulative {selection} (%)', fontsize=10, fontweight='bold')\nplt.xlim(0, 1)\nplt.ylim(0, 1)\n\n# Adjust grid and layout\nplt.grid(True, linestyle='-', color='grey', linewidth=0.08)\nplt.gca().set_aspect('equal', adjustable='box')\n\n# Add Data Source\nplt.text(0, -0.1, 'Data Source: World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\n\n# Variable notes\nnoteincome = 'Income: Post-tax national income is the sum of primary incomes over all sectors (private and public), minus taxes.'\nnotewealth = 'Wealth: Total value of non-financial and financial assets held by households, minus their debts.'\nnote = noteincome if selection == 'income' else notewealth\n\n# Add Notes\nplt.text(0, -0.12, note, \n    transform=plt.gca().transAxes, \n    fontsize=7,\n    fontstyle='italic',\n    color='gray')\n\n# Add Author\nplt.text(0.85, -0.1, '@guillemmaya.com', \n    transform=plt.gca().transAxes, \n    fontsize=9,\n    fontstyle='italic',\n    color='#212121')\n\n # Add Year label\nformatted_date = year\nplt.text(1, 1.06, f'{formatted_date}',\n    transform=plt.gca().transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Create custom lines\nintra_line = mlines.Line2D([], [], color='#808080', label=f'Gini Intra-Countries: {ginic}', linewidth=2)\ninter_line = mlines.Line2D([], [], color='#FF0000', label=f'Gini Inter-Countries: {giniw}', linewidth=2)\ninter_line.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\ninter_circle = mlines.Line2D([], [], marker='o', color='w', markerfacecolor='#FF0000', markeredgecolor='black', markersize=8, label='Inter-Countries', linewidth=0)\n\n# Add custom legend\nplt.legend(handles=[intra_line, inter_line])\n\n# Save the figure\nplt.savefig('C:/Users/guill/Desktop/FIG_WID_Global_Lorenz_Curves.png', format='png', dpi=300, bbox_inches='tight')\n\n# Show the plot!\nplt.show()"
  },
  {
    "objectID": "posts/202505-lorenz-curves/index.html#summary",
    "href": "posts/202505-lorenz-curves/index.html#summary",
    "title": "Lorenz Curves: A global and national perspectives",
    "section": "",
    "text": "This is a global graphical representation of income and wealth for the years 1995 and 2021. Illustrating the dynamics of inequality by comparing Gini indices through Lorenz curves, both within (intra-country) and between (inter-country) nations.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\nimport matplotlib.patheffects as patheffects\n\n# Parameters\n# =====================================================================\n# Select between Income/Wealth\nselection = 'Income'\nyear = 2021\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction (Percentages)\n# ===================================================\n# URL GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/WID_Percentiles.parquet\"\n\n# Extract data from parquet\ndf = pd.read_parquet(url, engine='pyarrow')\n\n# Filter year\ndf = df[df['year'] == year]\n\n# Data Extraction (Values)\n# ===================================================\n# URL GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Python/main/Data/WID_Values.parquet\"\n\n# Extract data from parquet\ndfv = pd.read_parquet(url, engine='pyarrow')\n\n# Filter year\ndfv = dfv[dfv['year'] == year]\n\n# Extract world values\ngincomew = dfv.loc[dfv['country'] == 'WO', 'gincome'].iloc[0]\ngwealthw = dfv.loc[dfv['country'] == 'WO', 'gwealth'].iloc[0]\n\n# Extract countries weighted average values\ndfincome = dfv[dfv['country'].isin(df_countries['ISO2']) & dfv['gincome'].notnull() & dfv['population'].notnull()]\ndfwealth = dfv[dfv['country'].isin(df_countries['ISO2']) & dfv['gwealth'].notnull() & dfv['population'].notnull()]\n\ngincomec = np.average(dfincome['gincome'], weights= dfincome['population'])\ngwealthc = np.average(dfwealth['gwealth'], weights= dfwealth['population'])\n\n# Dynamic value\nginiw = round(gwealthw, 2) if selection == 'Wealth' else round(gincomew, 2)\nginic= round(gwealthc, 2) if selection == 'Wealth' else round(gincomec, 2)\n\n# Data Manipulation\n# ===================================================\n# Calculate cummulative\ndf['percentile'] =  df['percentile'] / 100\ndf['income'] =  df['income'] / 100\ndf['wealth'] =  df['wealth'] / 100\ndf['income_cum'] =  df.groupby(['country'])['income'].cumsum() / df.groupby(['country'])['income'].transform('sum')\ndf['wealth_cum'] =  df.groupby(['country'])['wealth'].cumsum() / df.groupby(['country'])['wealth'].transform('sum')\ndf['value_cum'] = df['income_cum'] if selection == 'Income' else df['wealth_cum']\n\n# Countries\ndfc = df.merge(df_countries, how='left', left_on='country', right_on='ISO2')\ndfc = dfc[dfc['Region'].notna()]\ndfc = dfc[['country', 'percentile', 'value_cum']]\n\n# World\ndfw = df[df['country'] == \"WO\"]\ndfw = dfw[['country', 'percentile', 'value_cum']]\ndfw['country'] = 'Inter-Countries'\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\nplt.figure(figsize=(10, 10))\n\n# Basic Grey Plot Lines\nsns.lineplot(\n    data=dfc, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=0.4,\n    alpha=0.5,\n    palette=['#808080']\n).legend_.remove()\n\n# Black Shadow Plot Lines\nsns.lineplot(\n    data=dfw, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=2.25,\n    alpha=1,\n    palette=['black']\n).legend_.remove()\n\n# Color Plot Lines\nsns.lineplot(\n    data=dfw, \n    x=\"percentile\", \n    y=\"value_cum\", \n    hue=\"country\",\n    linewidth=1.5,\n    alpha=1,\n    palette=['#FF0000']\n).legend_.remove()\n\n# Add Inequality lines\nplt.plot([0, 1], [0, 1], color=\"gray\", linestyle=\"-\", linewidth=1)\n\n# Configuración del gráfico\nplt.text(0, 1.05, f'Global {selection} Distribution', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.02, 'A global and national perspective on Lorenz curves', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlabel('Cumulative Population (%)', fontsize=10, fontweight='bold')\nplt.ylabel(f'Cumulative {selection} (%)', fontsize=10, fontweight='bold')\nplt.xlim(0, 1)\nplt.ylim(0, 1)\n\n# Adjust grid and layout\nplt.grid(True, linestyle='-', color='grey', linewidth=0.08)\nplt.gca().set_aspect('equal', adjustable='box')\n\n# Add Data Source\nplt.text(0, -0.1, 'Data Source: World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\n\n# Variable notes\nnoteincome = 'Income: Post-tax national income is the sum of primary incomes over all sectors (private and public), minus taxes.'\nnotewealth = 'Wealth: Total value of non-financial and financial assets held by households, minus their debts.'\nnote = noteincome if selection == 'income' else notewealth\n\n# Add Notes\nplt.text(0, -0.12, note, \n    transform=plt.gca().transAxes, \n    fontsize=7,\n    fontstyle='italic',\n    color='gray')\n\n# Add Author\nplt.text(0.85, -0.1, '@guillemmaya.com', \n    transform=plt.gca().transAxes, \n    fontsize=9,\n    fontstyle='italic',\n    color='#212121')\n\n # Add Year label\nformatted_date = year\nplt.text(1, 1.06, f'{formatted_date}',\n    transform=plt.gca().transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Create custom lines\nintra_line = mlines.Line2D([], [], color='#808080', label=f'Gini Intra-Countries: {ginic}', linewidth=2)\ninter_line = mlines.Line2D([], [], color='#FF0000', label=f'Gini Inter-Countries: {giniw}', linewidth=2)\ninter_line.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\ninter_circle = mlines.Line2D([], [], marker='o', color='w', markerfacecolor='#FF0000', markeredgecolor='black', markersize=8, label='Inter-Countries', linewidth=0)\n\n# Add custom legend\nplt.legend(handles=[intra_line, inter_line])\n\n# Save the figure\nplt.savefig('C:/Users/guill/Desktop/FIG_WID_Global_Lorenz_Curves.png', format='png', dpi=300, bbox_inches='tight')\n\n# Show the plot!\nplt.show()"
  },
  {
    "objectID": "posts/202506-global-structure-economy/index.html",
    "href": "posts/202506-global-structure-economy/index.html",
    "title": "Global structure economy: A vision of GDP per capita and population",
    "section": "",
    "text": "This animation illustrates how the hegemony exerted by certain nations has aimed to preserve an unequal income distribution by capturing the greater share of the value chains over the past decades.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.ticker as ticker\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.CD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1960, 2024)\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'Year',\n    'SP.POP.TOTL': 'LP',\n    'NY.GDP.PCAP.CD': 'NGDPDPC'\n})\n\n# Adjust LP and filter before 1980\ndf_wb['LP'] = df_wb['LP'] / 1000000\ndf_wb = df_wb[df_wb['Year'] &lt; 1980]\n\n# Data Extraction - IMF (1980-2030)\n# =====================================================================\n#Parametro\nparameters = ['LP', 'NGDPDPC']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Pivot Parameter to columns and filter nulls\ndf_imf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\n\n# Filter after 2024\ndf_imf = df_imf[df_imf['Year'] &gt;= 1980]\n\n# Data Manipulation\n# =====================================================================\n# Concat and filter dataframes\ndf = pd.concat([df_wb, df_imf], ignore_index=True)\ndf = df.dropna(subset=['NGDPDPC', 'LP'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['ISO3', 'Country', 'Year', 'LP', 'NGDPDPC', 'Analytical', 'Region']]\ndf = df[df['Region'].notna()]\n\n# Create a list\ndfs = []\n\n# Interpolate monthly data\nfor iso3 in df['ISO3'].unique():\n    temp_df = df[df['ISO3'] == iso3].copy()\n    temp_df['Date'] = pd.to_datetime(temp_df['Year'], format='%Y')\n    temp_df = temp_df[['Date', 'LP', 'NGDPDPC']]\n    temp_df = temp_df.set_index('Date').resample('ME').mean().interpolate(method='linear').reset_index()\n    temp_df['ISO3'] = iso3\n    temp_df['Year'] = temp_df['Date'].dt.year \n    dfs.append(temp_df)\n    \n# Concat dataframes    \ndf = pd.concat(dfs, ignore_index=True)\n\n# Filter nulls and order\ndf = df.sort_values(by=['Year', 'NGDPDPC'])\n\n# Calculate 'left accrual widths'\ndf['LP_Cum'] = df.groupby('Date')['LP'].cumsum()\ndf['LP_Per'] = df['LP'] / df.groupby('Date')['LP'].transform('sum')\ndf['LP_Cum_Per'] = df['LP_Cum'] / df.groupby('Date')['LP_Cum'].transform('max')\ndf['Left'] = df['LP_Cum_Per'] - df['LP_Per']\n\n# Calculate GDP Average weighted by Population and partitioned by Year\ndf['AVG_Weight'] = df.groupby('Date')['NGDPDPC'].transform(lambda x: np.average(x, weights=df.loc[x.index, 'LP']))\n\n# Add a total GDP column and cummulative it\ndf['GDP'] = df['NGDPDPC'] * df['LP']\ndf['GDPcum'] = df.groupby('Date')['GDP'].cumsum()\ndf['GDP_Per'] = df['GDP'] / df.groupby('Date')['GDP'].transform('sum')\ndf['NGDPDPC_Change'] = ((df['NGDPDPC'] / df.groupby('ISO3')['NGDPDPC'].transform('first')) - 1) * 100\n\n# Copy a df sample to calculate a median\ndf_sample = df.copy()\ncolumns = df.columns\ndf_sample = np.repeat(df_sample.values, df_sample['LP'].astype(int), axis=0)\ndf_sample = pd.DataFrame(df_sample, columns=columns)\ndf_sample.dropna(subset=['NGDPDPC'], inplace=True)\ndf_sample['NGDPDPC'] = pd.to_numeric(df_sample['NGDPDPC'], errors='coerce')\ndf_sample['GDPcum'] = df_sample.groupby('Date')['NGDPDPC'].transform('cumsum')\n\n# Function to get median row\ndef medianrow(group):\n    medianrow = len(group) // 2  # Índice de la mitad\n    return group.iloc[medianrow]\ndf_sample = df_sample.groupby('Date').apply(medianrow).reset_index(drop=True)\n\n# Transform columns\ndf_sample = df_sample[['Date', 'NGDPDPC', 'GDPcum']].reset_index(drop=True)\ndf_sample = df_sample.rename(columns={'NGDPDPC': 'Median', 'GDPcum': 'Median_Total'})\n\n# Merge queries\ndf = df.merge(df_sample, how='left', on='Date')\n\n# Add percentage bottom 50\ndf['Median_Total_Per'] = df['Median_Total'] / df.groupby('Date')['GDP'].transform('sum')\n\nprint(df)\n \n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(16, 9))\n\n# Create a palette\npalette = sns.color_palette(\"coolwarm\", as_cmap=True).reversed()\n\n# Function to refresh animation\ndef update(date):\n    plt.clf()\n    subset = df[df['Date'] == date]\n    subset_usa = subset[subset['ISO3'] == 'USA'].copy()\n    \n    # Normalize GDPcum in a range [0, 1]\n    gdp_min = subset['GDPcum'].min()\n    gdp_max = subset_usa['GDPcum'].max()\n    norm = plt.Normalize(gdp_min, gdp_max)\n    colors = palette(norm(subset['GDPcum']))\n    \n    # Create a Matplotlib plot\n    bars = plt.bar(subset['Left'], subset['NGDPDPC'], width=subset['LP_Per'], \n            color=colors, alpha=1, align='edge', edgecolor='grey', linewidth=0.1)\n    \n    # Configuration grid and labels\n    plt.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n    plt.text(0, 1.02, 'Evolution of Countries from 1960 to 2029', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n    plt.xlim(0, subset['LP_Cum_Per'].max())\n    plt.ylim(0, subset_usa['NGDPDPC'].max() * 1.05)\n    plt.grid(axis='x')\n    plt.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n    plt.xlabel('Cumulative Global Population (%)', fontsize=10, fontweight='bold')\n    plt.ylabel('GDP per capita (US$)', fontsize=10, fontweight='bold')\n    plt.tick_params(axis='x', labelsize=9)\n    plt.tick_params(axis='y', labelsize=9)\n    plt.gca().xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(x*100):,}%'))\n    plt.gca().yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(round(x, -3)):,}'))\n    plt.xticks(np.linspace(0, subset['LP_Cum_Per'].max(), 5))\n    plt.yticks(np.linspace(0, subset_usa['NGDPDPC'].max() * 1.05, 8))\n        \n    # Add Labels to relevant countries\n    for bar, value, country in zip(bars, subset['GDP'], subset['ISO3']):\n        if country in ['CHN', 'IND', 'USA', 'IDN', 'PAK', 'NGA', 'BRA', 'BGD', 'RUS', 'MEX', 'JPN', 'VNM', 'DEU', 'GBR']:\n            plt.gca().text(bar.get_x() + bar.get_width()/2, bar.get_height(),\n                        f'{country}\\n{''}', ha='center', va='bottom', fontsize=7, color='grey')\n\n    # Add Median Line and Label\n    median = subset['Median'].max()\n    median_total = subset.iloc[0]['Median_Total']\n    median_total_per = subset.iloc[0]['Median_Total_Per']\n    maxis = subset_usa['NGDPDPC'].max()\n    \n    plt.axhline(\n        y=median,\n        color='darkred', \n        linestyle='--', \n        linewidth=0.5)\n\n    plt.text(\n        x=subset['Left'].max() * 0.02,\n        y=median + (maxis * 0.06),\n        s=f'GDP Capita Median: {median:,.0f}',\n        color='darkred',\n        verticalalignment='bottom',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold') \n\n    plt.gca().text(\n                subset['Left'].max() * 0.02,\n                median + (maxis * 0.04),\n                f'Bottom 50 - Total GDP: {median_total:,.0f} MM ({median_total_per * 100:.2f}%)', \n                ha='left', va='center', \n                fontsize=9, \n                color='#737373')\n    \n    # Add USA Line and Label\n    pibc_usa = subset_usa.iloc[0]['NGDPDPC']\n    pib_usa = subset_usa.iloc[0]['GDP']\n    pib_usa_per = subset_usa.iloc[0]['GDP_Per']\n    \n    plt.axhline(\n        y=pibc_usa, \n        color='darkblue', \n        linestyle='--', \n        linewidth=0.5)\n    \n    plt.text(\n        x=subset['Left'].max() * 0.02,\n        y=pibc_usa * 0.95,\n        s=f'GDP Capita USA: {pibc_usa:,.0f}',\n        color='darkblue',\n        fontsize=10,\n        verticalalignment='bottom',\n        horizontalalignment='left',\n        weight='bold')\n\n    plt.gca().text(\n                subset['Left'].max() * 0.02,\n                pibc_usa * 0.93,\n                f'USA - Total GDP: {pib_usa:,.0f} MM ({pib_usa_per * 100:.2f}%)', \n                ha='left', va='center', \n                fontsize=9, \n                color='#737373')\n\n    # Cover countries going outside plot\n    formatted_date = date.strftime('%Y-%m') \n    plt.text(1, 1.15, f'{formatted_date}',\n             transform=plt.gca().transAxes,\n             fontsize=22, ha='right', va='top',\n             fontweight='bold', color='white',\n             bbox=dict(facecolor='white', edgecolor='none', boxstyle='square,pad=1'))\n\n    # Add Year label\n    plt.text(1, 1.06, f'{formatted_date}',\n             transform=plt.gca().transAxes,\n             fontsize=22, ha='right', va='top',\n             fontweight='bold', color='#D3D3D3',\n             bbox=dict(facecolor='white', edgecolor='none', boxstyle='square,pad=0.3'))\n    \n    # Add Data Source\n    plt.text(0, -0.1, 'Data Source: IMF World Economic Outlook Database, 2024 | World Bank national accounts data, and OECD National Accounts data files.', \n            transform=plt.gca().transAxes, \n            fontsize=8, \n            color='gray')\n    \n    # Add author\n    plt.text(1, -0.1, '@guillemmaya.com', \n         transform=plt.gca().transAxes, \n         fontsize=8, \n         color='#212121', \n         ha='right')\n\n    # Add label \"poorest\" and \"richest\"\n    plt.text(0, -0.065, 'Poorest',\n             transform=ax.transAxes,\n             fontsize=12, fontweight='bold', color='darkred', ha='left', va='center')\n    plt.text(0.95, -0.065, 'Richest',\n             transform=ax.transAxes,\n             fontsize=12, fontweight='bold', color='darkblue', va='center')\n\n# Configurate animation\ndates = sorted(df['Date'].unique())\nani = animation.FuncAnimation(fig, update, frames=dates, repeat=False, interval=500, blit=False)\n\n# Save the animation :)\nani.save('C:/Users/guill/Downloads/FIG_GDP_Capita_Bars_1960.webp', writer='imagemagick', fps=15)\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202506-global-structure-economy/index.html#summary",
    "href": "posts/202506-global-structure-economy/index.html#summary",
    "title": "Global structure economy: A vision of GDP per capita and population",
    "section": "",
    "text": "This animation illustrates how the hegemony exerted by certain nations has aimed to preserve an unequal income distribution by capturing the greater share of the value chains over the past decades.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.ticker as ticker\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.CD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1960, 2024)\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'Year',\n    'SP.POP.TOTL': 'LP',\n    'NY.GDP.PCAP.CD': 'NGDPDPC'\n})\n\n# Adjust LP and filter before 1980\ndf_wb['LP'] = df_wb['LP'] / 1000000\ndf_wb = df_wb[df_wb['Year'] &lt; 1980]\n\n# Data Extraction - IMF (1980-2030)\n# =====================================================================\n#Parametro\nparameters = ['LP', 'NGDPDPC']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Pivot Parameter to columns and filter nulls\ndf_imf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\n\n# Filter after 2024\ndf_imf = df_imf[df_imf['Year'] &gt;= 1980]\n\n# Data Manipulation\n# =====================================================================\n# Concat and filter dataframes\ndf = pd.concat([df_wb, df_imf], ignore_index=True)\ndf = df.dropna(subset=['NGDPDPC', 'LP'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['ISO3', 'Country', 'Year', 'LP', 'NGDPDPC', 'Analytical', 'Region']]\ndf = df[df['Region'].notna()]\n\n# Create a list\ndfs = []\n\n# Interpolate monthly data\nfor iso3 in df['ISO3'].unique():\n    temp_df = df[df['ISO3'] == iso3].copy()\n    temp_df['Date'] = pd.to_datetime(temp_df['Year'], format='%Y')\n    temp_df = temp_df[['Date', 'LP', 'NGDPDPC']]\n    temp_df = temp_df.set_index('Date').resample('ME').mean().interpolate(method='linear').reset_index()\n    temp_df['ISO3'] = iso3\n    temp_df['Year'] = temp_df['Date'].dt.year \n    dfs.append(temp_df)\n    \n# Concat dataframes    \ndf = pd.concat(dfs, ignore_index=True)\n\n# Filter nulls and order\ndf = df.sort_values(by=['Year', 'NGDPDPC'])\n\n# Calculate 'left accrual widths'\ndf['LP_Cum'] = df.groupby('Date')['LP'].cumsum()\ndf['LP_Per'] = df['LP'] / df.groupby('Date')['LP'].transform('sum')\ndf['LP_Cum_Per'] = df['LP_Cum'] / df.groupby('Date')['LP_Cum'].transform('max')\ndf['Left'] = df['LP_Cum_Per'] - df['LP_Per']\n\n# Calculate GDP Average weighted by Population and partitioned by Year\ndf['AVG_Weight'] = df.groupby('Date')['NGDPDPC'].transform(lambda x: np.average(x, weights=df.loc[x.index, 'LP']))\n\n# Add a total GDP column and cummulative it\ndf['GDP'] = df['NGDPDPC'] * df['LP']\ndf['GDPcum'] = df.groupby('Date')['GDP'].cumsum()\ndf['GDP_Per'] = df['GDP'] / df.groupby('Date')['GDP'].transform('sum')\ndf['NGDPDPC_Change'] = ((df['NGDPDPC'] / df.groupby('ISO3')['NGDPDPC'].transform('first')) - 1) * 100\n\n# Copy a df sample to calculate a median\ndf_sample = df.copy()\ncolumns = df.columns\ndf_sample = np.repeat(df_sample.values, df_sample['LP'].astype(int), axis=0)\ndf_sample = pd.DataFrame(df_sample, columns=columns)\ndf_sample.dropna(subset=['NGDPDPC'], inplace=True)\ndf_sample['NGDPDPC'] = pd.to_numeric(df_sample['NGDPDPC'], errors='coerce')\ndf_sample['GDPcum'] = df_sample.groupby('Date')['NGDPDPC'].transform('cumsum')\n\n# Function to get median row\ndef medianrow(group):\n    medianrow = len(group) // 2  # Índice de la mitad\n    return group.iloc[medianrow]\ndf_sample = df_sample.groupby('Date').apply(medianrow).reset_index(drop=True)\n\n# Transform columns\ndf_sample = df_sample[['Date', 'NGDPDPC', 'GDPcum']].reset_index(drop=True)\ndf_sample = df_sample.rename(columns={'NGDPDPC': 'Median', 'GDPcum': 'Median_Total'})\n\n# Merge queries\ndf = df.merge(df_sample, how='left', on='Date')\n\n# Add percentage bottom 50\ndf['Median_Total_Per'] = df['Median_Total'] / df.groupby('Date')['GDP'].transform('sum')\n\nprint(df)\n \n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\nfig, ax = plt.subplots(figsize=(16, 9))\n\n# Create a palette\npalette = sns.color_palette(\"coolwarm\", as_cmap=True).reversed()\n\n# Function to refresh animation\ndef update(date):\n    plt.clf()\n    subset = df[df['Date'] == date]\n    subset_usa = subset[subset['ISO3'] == 'USA'].copy()\n    \n    # Normalize GDPcum in a range [0, 1]\n    gdp_min = subset['GDPcum'].min()\n    gdp_max = subset_usa['GDPcum'].max()\n    norm = plt.Normalize(gdp_min, gdp_max)\n    colors = palette(norm(subset['GDPcum']))\n    \n    # Create a Matplotlib plot\n    bars = plt.bar(subset['Left'], subset['NGDPDPC'], width=subset['LP_Per'], \n            color=colors, alpha=1, align='edge', edgecolor='grey', linewidth=0.1)\n    \n    # Configuration grid and labels\n    plt.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n    plt.text(0, 1.02, 'Evolution of Countries from 1960 to 2029', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n    plt.xlim(0, subset['LP_Cum_Per'].max())\n    plt.ylim(0, subset_usa['NGDPDPC'].max() * 1.05)\n    plt.grid(axis='x')\n    plt.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n    plt.xlabel('Cumulative Global Population (%)', fontsize=10, fontweight='bold')\n    plt.ylabel('GDP per capita (US$)', fontsize=10, fontweight='bold')\n    plt.tick_params(axis='x', labelsize=9)\n    plt.tick_params(axis='y', labelsize=9)\n    plt.gca().xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(x*100):,}%'))\n    plt.gca().yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: f'{int(round(x, -3)):,}'))\n    plt.xticks(np.linspace(0, subset['LP_Cum_Per'].max(), 5))\n    plt.yticks(np.linspace(0, subset_usa['NGDPDPC'].max() * 1.05, 8))\n        \n    # Add Labels to relevant countries\n    for bar, value, country in zip(bars, subset['GDP'], subset['ISO3']):\n        if country in ['CHN', 'IND', 'USA', 'IDN', 'PAK', 'NGA', 'BRA', 'BGD', 'RUS', 'MEX', 'JPN', 'VNM', 'DEU', 'GBR']:\n            plt.gca().text(bar.get_x() + bar.get_width()/2, bar.get_height(),\n                        f'{country}\\n{''}', ha='center', va='bottom', fontsize=7, color='grey')\n\n    # Add Median Line and Label\n    median = subset['Median'].max()\n    median_total = subset.iloc[0]['Median_Total']\n    median_total_per = subset.iloc[0]['Median_Total_Per']\n    maxis = subset_usa['NGDPDPC'].max()\n    \n    plt.axhline(\n        y=median,\n        color='darkred', \n        linestyle='--', \n        linewidth=0.5)\n\n    plt.text(\n        x=subset['Left'].max() * 0.02,\n        y=median + (maxis * 0.06),\n        s=f'GDP Capita Median: {median:,.0f}',\n        color='darkred',\n        verticalalignment='bottom',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold') \n\n    plt.gca().text(\n                subset['Left'].max() * 0.02,\n                median + (maxis * 0.04),\n                f'Bottom 50 - Total GDP: {median_total:,.0f} MM ({median_total_per * 100:.2f}%)', \n                ha='left', va='center', \n                fontsize=9, \n                color='#737373')\n    \n    # Add USA Line and Label\n    pibc_usa = subset_usa.iloc[0]['NGDPDPC']\n    pib_usa = subset_usa.iloc[0]['GDP']\n    pib_usa_per = subset_usa.iloc[0]['GDP_Per']\n    \n    plt.axhline(\n        y=pibc_usa, \n        color='darkblue', \n        linestyle='--', \n        linewidth=0.5)\n    \n    plt.text(\n        x=subset['Left'].max() * 0.02,\n        y=pibc_usa * 0.95,\n        s=f'GDP Capita USA: {pibc_usa:,.0f}',\n        color='darkblue',\n        fontsize=10,\n        verticalalignment='bottom',\n        horizontalalignment='left',\n        weight='bold')\n\n    plt.gca().text(\n                subset['Left'].max() * 0.02,\n                pibc_usa * 0.93,\n                f'USA - Total GDP: {pib_usa:,.0f} MM ({pib_usa_per * 100:.2f}%)', \n                ha='left', va='center', \n                fontsize=9, \n                color='#737373')\n\n    # Cover countries going outside plot\n    formatted_date = date.strftime('%Y-%m') \n    plt.text(1, 1.15, f'{formatted_date}',\n             transform=plt.gca().transAxes,\n             fontsize=22, ha='right', va='top',\n             fontweight='bold', color='white',\n             bbox=dict(facecolor='white', edgecolor='none', boxstyle='square,pad=1'))\n\n    # Add Year label\n    plt.text(1, 1.06, f'{formatted_date}',\n             transform=plt.gca().transAxes,\n             fontsize=22, ha='right', va='top',\n             fontweight='bold', color='#D3D3D3',\n             bbox=dict(facecolor='white', edgecolor='none', boxstyle='square,pad=0.3'))\n    \n    # Add Data Source\n    plt.text(0, -0.1, 'Data Source: IMF World Economic Outlook Database, 2024 | World Bank national accounts data, and OECD National Accounts data files.', \n            transform=plt.gca().transAxes, \n            fontsize=8, \n            color='gray')\n    \n    # Add author\n    plt.text(1, -0.1, '@guillemmaya.com', \n         transform=plt.gca().transAxes, \n         fontsize=8, \n         color='#212121', \n         ha='right')\n\n    # Add label \"poorest\" and \"richest\"\n    plt.text(0, -0.065, 'Poorest',\n             transform=ax.transAxes,\n             fontsize=12, fontweight='bold', color='darkred', ha='left', va='center')\n    plt.text(0.95, -0.065, 'Richest',\n             transform=ax.transAxes,\n             fontsize=12, fontweight='bold', color='darkblue', va='center')\n\n# Configurate animation\ndates = sorted(df['Date'].unique())\nani = animation.FuncAnimation(fig, update, frames=dates, repeat=False, interval=500, blit=False)\n\n# Save the animation :)\nani.save('C:/Users/guill/Downloads/FIG_GDP_Capita_Bars_1960.webp', writer='imagemagick', fps=15)\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202507-gdpc-europe-nuts2/index.html",
    "href": "posts/202507-gdpc-europe-nuts2/index.html",
    "title": "European Regions NUTS2: GDP per Capita",
    "section": "",
    "text": "The chart displays regional GDP per capita adjusted for purchasing power standards (PPS) at the NUTS 2 level, highlighting economic disparities across European regions.\n\n\nCode\n# Libraries\n# ======================================\nimport eurostat\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as mcolors\nimport matplotlib.patches as mpatches\n\n# EUROSTAT Data\n# ======================================\n# Get Data from Eurostat\ndataset = eurostat.get_data_df('TGS00005')\ndf = pd.DataFrame(dataset)\n\n# Select and rename columns\ndf = df[['geo\\TIME_PERIOD', '2019']]\ndf = df.rename(columns={'geo\\\\TIME_PERIOD': 'geo'})\n\n# GEOPANDAS Data\n# ======================================\n# Read GEOJSON file\ngeojson_url = \"https://gisco-services.ec.europa.eu/distribution/v2/nuts/geojson/NUTS_RG_60M_2021_4326_LEVL_2.geojson\"\ngdf = gpd.read_file(geojson_url)\n\n# Merge dataframes\ngdf = gdf.merge(df, left_on='NUTS_ID', right_on='geo')\n\n# Filter french islands\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('FRY')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('ES70')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('PT20')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('PT30')]\n\n# STATIC Map\n# ======================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create figure\nfig, ax = plt.subplots(1, 1, figsize=(12, 12))\n\n# Define palette range\nranges = [7000, 16000, 22000, 27000, 32000, 38000, 80000]\ncolors = ['#d66d35', '#e5a53e', '#efcd94', '#d5dcef', '#88a0d0', '#4b6cb0']  # Colores específicos para cada rango\nlabels = [\n    '≥ 5 700 to 12 800',\n    '≥ 12 800 to 17 600',\n    '≥ 17 600 to 22 000',\n    '≥ 22 000 to 27 000',\n    '≥ 27 000 to 32 200',\n    '≥ 32 200 to 70 400'\n]\n\n# Plot Map\ngdf.plot(\n    column='2019', \n    ax=ax, \n    legend=False,\n    cmap=mcolors.ListedColormap(colors), \n    linewidth=0.15, \n    edgecolor='black', \n    norm=mcolors.BoundaryNorm(boundaries=ranges, ncolors=len(colors))\n)\n\n# Custom Legend\npatches = [mpatches.Patch(color=color, label=label) for color, label in zip(colors, labels)]\nlegend = ax.legend(\n    handles=patches, \n    loc='upper left', \n    fontsize=8, \n    title=\"GDP per capita\", \n    title_fontsize=9, \n    labelspacing=0.5, \n    borderpad=0.3\n)\nlegend.get_title().set_fontweight('bold')\nplt.subplots_adjust(right=0.8)\n\n# Configuration\nplt.text(0, 1.05, 'Regional GDP per capita', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.02, 'By NUTS 2 Region (Europe)', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\nax.set_axis_off()\n\n # Add Year label\nformatted_date = 2019 \nax.text(1, 1.06, f'{formatted_date}',\n    transform=ax.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nplt.text(0, -0.1, 'Data Source: Eurostat (2024), GDP and main components (output, expenditure and income)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight = 'bold',\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.12, 'Notes: Gross domestic product (GDP) at current market prices by NUTS 2 region', \n    transform=plt.gca().transAxes,\n    fontsize=8, \n    color='gray')\n\n# Add author\nplt.text(1, -0.1, '@guillemmaya.com', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='#212121', \n    ha='right')\n\n# Save it!\nplt.savefig('C:/Users/guill/Downloads/FIG_EUROSTAT_Map_GDP.png', format='png', bbox_inches='tight')\n\n# Plot it!\nplt.show()"
  },
  {
    "objectID": "posts/202507-gdpc-europe-nuts2/index.html#summary",
    "href": "posts/202507-gdpc-europe-nuts2/index.html#summary",
    "title": "European Regions NUTS2: GDP per Capita",
    "section": "",
    "text": "The chart displays regional GDP per capita adjusted for purchasing power standards (PPS) at the NUTS 2 level, highlighting economic disparities across European regions.\n\n\nCode\n# Libraries\n# ======================================\nimport eurostat\nimport pandas as pd\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\nimport matplotlib.colors as mcolors\nimport matplotlib.patches as mpatches\n\n# EUROSTAT Data\n# ======================================\n# Get Data from Eurostat\ndataset = eurostat.get_data_df('TGS00005')\ndf = pd.DataFrame(dataset)\n\n# Select and rename columns\ndf = df[['geo\\TIME_PERIOD', '2019']]\ndf = df.rename(columns={'geo\\\\TIME_PERIOD': 'geo'})\n\n# GEOPANDAS Data\n# ======================================\n# Read GEOJSON file\ngeojson_url = \"https://gisco-services.ec.europa.eu/distribution/v2/nuts/geojson/NUTS_RG_60M_2021_4326_LEVL_2.geojson\"\ngdf = gpd.read_file(geojson_url)\n\n# Merge dataframes\ngdf = gdf.merge(df, left_on='NUTS_ID', right_on='geo')\n\n# Filter french islands\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('FRY')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('ES70')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('PT20')]\ngdf = gdf[~gdf['NUTS_ID'].str.startswith('PT30')]\n\n# STATIC Map\n# ======================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create figure\nfig, ax = plt.subplots(1, 1, figsize=(12, 12))\n\n# Define palette range\nranges = [7000, 16000, 22000, 27000, 32000, 38000, 80000]\ncolors = ['#d66d35', '#e5a53e', '#efcd94', '#d5dcef', '#88a0d0', '#4b6cb0']  # Colores específicos para cada rango\nlabels = [\n    '≥ 5 700 to 12 800',\n    '≥ 12 800 to 17 600',\n    '≥ 17 600 to 22 000',\n    '≥ 22 000 to 27 000',\n    '≥ 27 000 to 32 200',\n    '≥ 32 200 to 70 400'\n]\n\n# Plot Map\ngdf.plot(\n    column='2019', \n    ax=ax, \n    legend=False,\n    cmap=mcolors.ListedColormap(colors), \n    linewidth=0.15, \n    edgecolor='black', \n    norm=mcolors.BoundaryNorm(boundaries=ranges, ncolors=len(colors))\n)\n\n# Custom Legend\npatches = [mpatches.Patch(color=color, label=label) for color, label in zip(colors, labels)]\nlegend = ax.legend(\n    handles=patches, \n    loc='upper left', \n    fontsize=8, \n    title=\"GDP per capita\", \n    title_fontsize=9, \n    labelspacing=0.5, \n    borderpad=0.3\n)\nlegend.get_title().set_fontweight('bold')\nplt.subplots_adjust(right=0.8)\n\n# Configuration\nplt.text(0, 1.05, 'Regional GDP per capita', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.02, 'By NUTS 2 Region (Europe)', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\nax.set_axis_off()\n\n # Add Year label\nformatted_date = 2019 \nax.text(1, 1.06, f'{formatted_date}',\n    transform=ax.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nplt.text(0, -0.1, 'Data Source: Eurostat (2024), GDP and main components (output, expenditure and income)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight = 'bold',\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.12, 'Notes: Gross domestic product (GDP) at current market prices by NUTS 2 region', \n    transform=plt.gca().transAxes,\n    fontsize=8, \n    color='gray')\n\n# Add author\nplt.text(1, -0.1, '@guillemmaya.com', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='#212121', \n    ha='right')\n\n# Save it!\nplt.savefig('C:/Users/guill/Downloads/FIG_EUROSTAT_Map_GDP.png', format='png', bbox_inches='tight')\n\n# Plot it!\nplt.show()"
  },
  {
    "objectID": "posts/202508-wid-beta-evolution/index.html",
    "href": "posts/202508-wid-beta-evolution/index.html",
    "title": "Capital is Back: From Labor to Capital in the Modern Economy",
    "section": "",
    "text": "The chart illustration the evolution of thel wealth-income ratio from 1980 to 2023 highlights the interplay between wealth accumulation and income generation over last five decades. It reveals a clear upward trend, reflecting the disproportionate growth of wealth relative to income, particularly in recent decades. This relationship is largely determined by the growth of the economy relative to the growth of capital. When capital grows at a faster rate than the economy, wealth concentrates disproportionately, amplifying disparities and altering the balance of economic power.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\nimport matplotlib.patheffects as patheffects\nimport matplotlib.font_manager as fm\nimport matplotlib.image as mpimg\nfrom io import BytesIO\n\n# Extract Data (Countries)\n# ===================================================\n# Extract JSON to dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Extract Data (WID)\n# ===================================================\n# Extract PARQUET to dataframe\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Analytics/master/Data/WID_Values.parquet\"\ndf = pd.read_parquet(url, engine=\"pyarrow\")\n\n# Transform Data\n# ===================================================\n# Filter nulls and countries\ndf = df[df['wiratio'].notna()]\ndf = pd.merge(df, df_countries, left_on='country', right_on='ISO2', how='inner')\n\n# Rename columns\ndf = df.rename(\n        columns={\n            'Country_Abr': 'country_name',\n            'wiratio': 'beta'\n        }\n    )\n\n# Filter countries have data post 1980\ndfx = df.loc[df['year'] == 1980, 'country']\ndf = df[df['country'].isin(dfx)]\ndf = df[df['year'] &gt;= 1980]\ndf = df[df['Analytical'] == 'Advanced Economies']\n\n# Dataframe countries\ndfc = df[df['country'].isin(['CN', 'US', 'FR', 'DE', 'ES'])]\n\n# Select columns and order\ndf = df[['year', 'country', 'country_name', 'beta']]\n\nprint(df)\n\n# Visualization Data\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create color dictionaire \npalette = {'CN': '#ffc2c2', 'US': '#c2d2ff', 'FR': '#c2ffcb', 'DE': '#e5c2ff', 'ES': '#fffac2'}\n\n# Create line plots\nplt.figure(figsize=(12, 8))\nsns.lineplot(data=df, x='year', y='beta', hue='country', linewidth=0.3, alpha=0.5, palette=['gray'], legend=False)\nsns.lineplot(data=dfc, x='year', y='beta', hue='country', linewidth=2.25, palette=['black'], legend=False)\nsns.lineplot(data=dfc, x='year', y='beta', hue='country', linewidth=1.5, palette=palette, legend=False)\n\n# Custom plot\nplt.text(0, 1.08, 'Capital is back', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.045, 'Wealth-Income Ratios in Advanced Economies 1980-2023', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlabel('Year', fontsize=10, fontweight='bold')\nplt.ylabel('Wealth-Income Ratio', fontsize=10, fontweight='bold')\nplt.grid(axis='x', alpha=0.7, linestyle=':')\nplt.ylim(0, 12)\nplt.xlim(1980, 2026)\nplt.xticks(range(1980, 2026, 10))\nplt.tight_layout()\n\n# Delete spines\nfor spine in [\"top\", \"right\"]:\n    plt.gca().spines[spine].set_visible(False)\n\n# Add Data Source\nplt.text(0, -0.08, 'Data Source: World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.1, 'Notes: Wealth-Income Ratio is the division of national wealth by national income.', \n    transform=plt.gca().transAxes, \n    fontsize=7,\n    fontstyle='italic',\n    color='gray')\n\n # Add Year label\nformatted_date = 2023\nplt.text(1, 1.08, f'{formatted_date}',\n    transform=plt.gca().transAxes,\n    fontsize=20, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Legend values\nbeta_cn = round(df[(df['country'] == 'CN') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_de = round(df[(df['country'] == 'DE') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_es = round(df[(df['country'] == 'ES') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_fr = round(df[(df['country'] == 'FR') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_us = round(df[(df['country'] == 'US') & (df['year'] == 2023)]['beta'].values[0], 1)\n\n# Legend lines\nline1 = mlines.Line2D([], [], color=palette['CN'], label=f'China: {beta_cn}', linewidth=2)\nline2 = mlines.Line2D([], [], color=palette['DE'], label=f'Germany: {beta_de}', linewidth=2)\nline3 = mlines.Line2D([], [], color=palette['ES'], label=f'Spain: {beta_es}', linewidth=2)\nline4 = mlines.Line2D([], [], color=palette['FR'], label=f'France: {beta_fr}', linewidth=2)\nline5 = mlines.Line2D([], [], color=palette['US'], label=f'USA: {beta_us}', linewidth=2)\nline6 = mlines.Line2D([], [], color='grey', label=f'Advanced economies', linewidth=1)\nline1.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline2.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline3.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline4.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline5.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\n\n# Legend plot\nplt.legend(handles=[line1, line2, line3, line4, line5, line6], title='Countries', fontsize=9, title_fontproperties=fm.FontProperties(weight='bold'))\n\n# Define flags\nflag_urls = {\n    'CN': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/CN.png',\n    'US': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/US.png',\n    'FR': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/FR.png',\n    'ES': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/ES.png',\n    'DE': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/DE.png'\n}\n\n# Load flags\nflags = {country: mpimg.imread(BytesIO(requests.get(url).content)) for country, url in flag_urls.items()}\n\n# Add flags\nyear = 2023\n# Adjust flags items\nfor country, flag in flags.items():\n    # Find beta for each country\n    beta_value = df[(df['country'] == country) & (df['year'] == year)]['beta'].values[0]\n    \n    if country == 'CN':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'DE':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'ES':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'FR':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.4, beta_value + 0], alpha=0.7)\n    elif country == 'US':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.4, beta_value + 0], alpha=0.7)\n\n# Save the animation :)\nplt.savefig(\"C:/Users/guill/Downloads/FIG_WID_Beta_Evolution.png\", dpi=300, bbox_inches='tight') \n\n# Show plot\nplt.show()"
  },
  {
    "objectID": "posts/202508-wid-beta-evolution/index.html#summary",
    "href": "posts/202508-wid-beta-evolution/index.html#summary",
    "title": "Capital is Back: From Labor to Capital in the Modern Economy",
    "section": "",
    "text": "The chart illustration the evolution of thel wealth-income ratio from 1980 to 2023 highlights the interplay between wealth accumulation and income generation over last five decades. It reveals a clear upward trend, reflecting the disproportionate growth of wealth relative to income, particularly in recent decades. This relationship is largely determined by the growth of the economy relative to the growth of capital. When capital grows at a faster rate than the economy, wealth concentrates disproportionately, amplifying disparities and altering the balance of economic power.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.lines as mlines\nimport matplotlib.patheffects as patheffects\nimport matplotlib.font_manager as fm\nimport matplotlib.image as mpimg\nfrom io import BytesIO\n\n# Extract Data (Countries)\n# ===================================================\n# Extract JSON to dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Extract Data (WID)\n# ===================================================\n# Extract PARQUET to dataframe\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Analytics/master/Data/WID_Values.parquet\"\ndf = pd.read_parquet(url, engine=\"pyarrow\")\n\n# Transform Data\n# ===================================================\n# Filter nulls and countries\ndf = df[df['wiratio'].notna()]\ndf = pd.merge(df, df_countries, left_on='country', right_on='ISO2', how='inner')\n\n# Rename columns\ndf = df.rename(\n        columns={\n            'Country_Abr': 'country_name',\n            'wiratio': 'beta'\n        }\n    )\n\n# Filter countries have data post 1980\ndfx = df.loc[df['year'] == 1980, 'country']\ndf = df[df['country'].isin(dfx)]\ndf = df[df['year'] &gt;= 1980]\ndf = df[df['Analytical'] == 'Advanced Economies']\n\n# Dataframe countries\ndfc = df[df['country'].isin(['CN', 'US', 'FR', 'DE', 'ES'])]\n\n# Select columns and order\ndf = df[['year', 'country', 'country_name', 'beta']]\n\nprint(df)\n\n# Visualization Data\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create color dictionaire \npalette = {'CN': '#ffc2c2', 'US': '#c2d2ff', 'FR': '#c2ffcb', 'DE': '#e5c2ff', 'ES': '#fffac2'}\n\n# Create line plots\nplt.figure(figsize=(12, 8))\nsns.lineplot(data=df, x='year', y='beta', hue='country', linewidth=0.3, alpha=0.5, palette=['gray'], legend=False)\nsns.lineplot(data=dfc, x='year', y='beta', hue='country', linewidth=2.25, palette=['black'], legend=False)\nsns.lineplot(data=dfc, x='year', y='beta', hue='country', linewidth=1.5, palette=palette, legend=False)\n\n# Custom plot\nplt.text(0, 1.08, 'Capital is back', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.045, 'Wealth-Income Ratios in Advanced Economies 1980-2023', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlabel('Year', fontsize=10, fontweight='bold')\nplt.ylabel('Wealth-Income Ratio', fontsize=10, fontweight='bold')\nplt.grid(axis='x', alpha=0.7, linestyle=':')\nplt.ylim(0, 12)\nplt.xlim(1980, 2026)\nplt.xticks(range(1980, 2026, 10))\nplt.tight_layout()\n\n# Delete spines\nfor spine in [\"top\", \"right\"]:\n    plt.gca().spines[spine].set_visible(False)\n\n# Add Data Source\nplt.text(0, -0.08, 'Data Source: World Inequality Database (WID)', \n    transform=plt.gca().transAxes, \n    fontsize=8,\n    fontweight='bold',\n    color='gray')\n\n# Add Notes\nplt.text(0, -0.1, 'Notes: Wealth-Income Ratio is the division of national wealth by national income.', \n    transform=plt.gca().transAxes, \n    fontsize=7,\n    fontstyle='italic',\n    color='gray')\n\n # Add Year label\nformatted_date = 2023\nplt.text(1, 1.08, f'{formatted_date}',\n    transform=plt.gca().transAxes,\n    fontsize=20, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Legend values\nbeta_cn = round(df[(df['country'] == 'CN') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_de = round(df[(df['country'] == 'DE') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_es = round(df[(df['country'] == 'ES') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_fr = round(df[(df['country'] == 'FR') & (df['year'] == 2023)]['beta'].values[0], 1)\nbeta_us = round(df[(df['country'] == 'US') & (df['year'] == 2023)]['beta'].values[0], 1)\n\n# Legend lines\nline1 = mlines.Line2D([], [], color=palette['CN'], label=f'China: {beta_cn}', linewidth=2)\nline2 = mlines.Line2D([], [], color=palette['DE'], label=f'Germany: {beta_de}', linewidth=2)\nline3 = mlines.Line2D([], [], color=palette['ES'], label=f'Spain: {beta_es}', linewidth=2)\nline4 = mlines.Line2D([], [], color=palette['FR'], label=f'France: {beta_fr}', linewidth=2)\nline5 = mlines.Line2D([], [], color=palette['US'], label=f'USA: {beta_us}', linewidth=2)\nline6 = mlines.Line2D([], [], color='grey', label=f'Advanced economies', linewidth=1)\nline1.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline2.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline3.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline4.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\nline5.set_path_effects([patheffects.withStroke(linewidth=4, foreground='black')])\n\n# Legend plot\nplt.legend(handles=[line1, line2, line3, line4, line5, line6], title='Countries', fontsize=9, title_fontproperties=fm.FontProperties(weight='bold'))\n\n# Define flags\nflag_urls = {\n    'CN': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/CN.png',\n    'US': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/US.png',\n    'FR': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/FR.png',\n    'ES': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/ES.png',\n    'DE': 'https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/DE.png'\n}\n\n# Load flags\nflags = {country: mpimg.imread(BytesIO(requests.get(url).content)) for country, url in flag_urls.items()}\n\n# Add flags\nyear = 2023\n# Adjust flags items\nfor country, flag in flags.items():\n    # Find beta for each country\n    beta_value = df[(df['country'] == country) & (df['year'] == year)]['beta'].values[0]\n    \n    if country == 'CN':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'DE':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'ES':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.2, beta_value + 0.2], alpha=0.7)\n    elif country == 'FR':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.4, beta_value + 0], alpha=0.7)\n    elif country == 'US':\n        plt.imshow(flag, aspect='auto', extent=[year+1, year+2, beta_value - 0.4, beta_value + 0], alpha=0.7)\n\n# Save the animation :)\nplt.savefig(\"C:/Users/guill/Downloads/FIG_WID_Beta_Evolution.png\", dpi=300, bbox_inches='tight') \n\n# Show plot\nplt.show()"
  },
  {
    "objectID": "posts/202509-wid-beta-2023/index.html",
    "href": "posts/202509-wid-beta-2023/index.html",
    "title": "Global Patterns in Wealth-Income Ratios",
    "section": "",
    "text": "A plot that shows a snapshot of the wealth-income ratio in 2023, offering insight into the current economic landscape.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Extract Data (Countries)\n# ===================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Extract Data (WID)\n# ===================================================\n# URL del archivo Parquet en GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Analytics/master/Data/WID_Values.parquet\"\ndf = pd.read_parquet(url, engine=\"pyarrow\")\ndf = df[df['year'].isin([1980, 2023])]\n\n# Transform Data\n# ===================================================\ndf['tincome'] = df['tincome2'] / df['xusd'] / 1000\ndf['twealth'] = df['twealth2'] / df['xusd'] / 1000\ndf['gdptotal'] = df['gdptotal'] / df['xusd']\ndf['tincomeVAR'] = (df['tincome'] / df.groupby('country')['tincome'].shift(1) -1) * 100\ndf['twealthVAR'] = (df['twealth'] / df.groupby('country')['twealth'].shift(1) -1) * 100\ndf['wiratioVAR'] = (df['wiratio'] - df.groupby('country')['wiratio'].shift(1))\ndf = df[df['year'] == 2023]\ndf = df[df['wiratio'].notna() & df['tincome'].notna()]\ndf = pd.merge(df, df_countries, left_on='country', right_on='ISO2', how='inner')\ndf = df[['year', 'country', 'Country_Abr', 'gdptotal', 'tincome', 'twealth', 'wiratio', 'tincomeVAR', 'twealthVAR', 'wiratioVAR']]\ndf = df[(df['tincome'] &gt;= 0) & (df['tincome'] &lt;= 120000)]\ndf = df.sort_values(by='gdptotal', ascending=True)\ndf = df.rename(\n        columns={\n            'year': 'year',\n            'Country_Abr': 'country_name',\n            'gdptotal': 'total_income',\n            'tincome': 'incomeCY',\n            'twealth': 'wealthCY', \n            'wiratio': 'betaCY',\n            'tincomeVAR': 'incomeVAR',\n            'twealthVAR': 'wealthVAR',\n            'wiratioVAR': 'betaVAR'\n        }\n    )\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Crea la figura\nfig = go.Figure()\n\n# Marker size y line width calculados\nmarker_size = np.sqrt(df[\"total_income\"] / df[\"total_income\"].max()) * 100 + 3\nline_width  = np.sqrt(df[\"total_income\"] / df[\"total_income\"].max()) * 4 + 0.5\n\n# Primero agregamos los puntos del scatter\nfig.add_trace(go.Scatter(\n    x=df[\"betaCY\"],\n    y=df[\"incomeCY\"],\n    mode='markers',\n    text=df[\"country_name\"],\n    customdata=np.vstack((df[\"incomeCY\"], df[\"wealthCY\"], df[\"incomeVAR\"], df[\"wealthVAR\"], df[\"betaCY\"], df[\"betaVAR\"])).T,\n    marker=dict(\n        size=marker_size,\n        color=\"rgba(0,0,0,0)\",\n        line=dict(\n            width=line_width,\n            color='black'\n        )\n    ),\n    hovertemplate=\"&lt;b&gt;Country:&lt;/b&gt; %{text}&lt;br&gt;\" +\n                  \"&lt;b&gt;Income Avg ($):&lt;/b&gt; %{y:.0f}k | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[2]:.2f}%&lt;br&gt;\" + \n                  \"&lt;b&gt;Wealth Avg ($):&lt;/b&gt; %{customdata[1]:.0f}k | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[3]:.2f}%&lt;br&gt;\" +\n                  \"&lt;b&gt;Ratio:&lt;/b&gt; %{customdata[4]:.2f} | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[5]:.2f}pp&lt;extra&gt;&lt;/extra&gt;\",\n    showlegend=False\n))\n\n# Ahora agregamos las imágenes de las banderas\nfor i, row in df.iterrows():\n    country_iso = row[\"country\"]\n    \n    # Calcular tamaño de la imagen\n    image_size = marker_size[i] * 0.205\n\n    # Añadir la imagen de la bandera, asegurándose de que el orden es correcto\n    fig.add_layout_image(\n        dict(\n            source=f\"https://raw.githubusercontent.com/guillemmaya92/world_flags_round/refs/heads/master/flags/{country_iso}.png\",\n            xref=\"x\",\n            yref=\"y\",\n            xanchor=\"center\",\n            yanchor=\"middle\",\n            x=row[\"betaCY\"],\n            y=row[\"incomeCY\"],\n            sizex=image_size,\n            sizey=image_size,\n            sizing=\"contain\",\n            opacity=0.8\n        )\n    )\n\n# Add red and green shapes\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=0, x1=6,\n    y0=0, y1=1,\n    fillcolor=\"green\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=6, x1=12,\n    y0=0, y1=1,\n    fillcolor=\"red\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\n\n# Configuration plot\nfig.update_layout(\n    title=\"&lt;b&gt;Wealth-Income Ratio&lt;/b&gt;\",\n    title_x=0.11,\n    title_y=0.93,\n    title_font=dict(size=16),\n    annotations=[\n        dict(\n            text=\"Global Patterns in Wealth-Income Ratios and Average Income per Capita\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.06,\n            showarrow=False,\n            font=dict(size=11)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; World Inequality Database (WID)\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.12,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"&lt;b&gt;Currency:&lt;/b&gt; Official exchange rate {df[\"year\"].max()} of the local currency to USD.\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.14,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"&lt;i&gt;@guillemmaya&lt;/i&gt;\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=1,\n            y=-0.14,\n            showarrow=False,\n            font=dict(size=11),\n            align=\"right\"\n        ),\n        dict(\n            text=str(df[\"year\"].max()),\n            xref=\"paper\", \n            yref=\"paper\",\n            x=1, \n            y=1.08,\n            showarrow=False,\n            font=dict(size=22, color='lightgray', weight='bold'),\n            align=\"right\"\n        )\n    ],\n    xaxis=dict(\n        title=\"&lt;b&gt;Wealth-Income Ratio&lt;/b&gt;\",\n        range=[0, 12],\n        tickvals=[i *  4 / 2 for i in range(7)],\n        ticktext=[f\"{int(i * 4 / 2)}\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    yaxis=dict(\n        title=\"&lt;b&gt;Average Income per Capita ($US)&lt;/b&gt;\",\n        range=[0, 120],\n        tickvals=[i * 120 / 6 for i in range(7)],\n        ticktext=[f\"{int(i * 120 / 6)}k\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    height=750,\n    width=750,\n    plot_bgcolor=\"white\",   \n    paper_bgcolor=\"white\"\n)\n\n# Add a custom legend\nsize_legend = ['Smaller', 'Middle', 'Bigger']\nsize_values = [5, 10, 20]\n\nfor label, size in zip(size_legend, size_values):\n    fig.add_trace(go.Scatter(\n        x=[None],\n        y=[None],\n        mode='markers',\n        marker=dict(\n            size=size,\n            color=\"rgba(0,0,0,0)\",\n            line=dict(\n                width=1,\n                color='black'\n            )\n        ),\n        legendgroup='size',\n        showlegend=True,\n        name=f'{label}'\n    ))\n\nfig.update_layout(\n    legend=dict(\n        title=dict(text='&lt;b&gt;  Total Income&lt;/b&gt;'), \n        font=dict(size=11),\n        x=0.025,\n        y=0.95,\n        xanchor='left',\n        bgcolor='white',\n        bordercolor='black',\n        borderwidth=1\n    )\n)\n\n# Save as HTML file!\nfig.write_html(\"C:/Users/guill/Desktop/FIG_WID_CapitalisBack_Flag.html\")\nfig.write_image(\"C:/Users/guill/Desktop/FIG_WID_CapitalisBack_Flag.png\")\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202509-wid-beta-2023/index.html#summary",
    "href": "posts/202509-wid-beta-2023/index.html#summary",
    "title": "Global Patterns in Wealth-Income Ratios",
    "section": "",
    "text": "A plot that shows a snapshot of the wealth-income ratio in 2023, offering insight into the current economic landscape.\n\n\nCode\n# Libraries\n# ===================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport plotly.graph_objects as go\n\n# Extract Data (Countries)\n# ===================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Extract Data (WID)\n# ===================================================\n# URL del archivo Parquet en GitHub\nurl = \"https://raw.githubusercontent.com/guillemmaya92/Analytics/master/Data/WID_Values.parquet\"\ndf = pd.read_parquet(url, engine=\"pyarrow\")\ndf = df[df['year'].isin([1980, 2023])]\n\n# Transform Data\n# ===================================================\ndf['tincome'] = df['tincome2'] / df['xusd'] / 1000\ndf['twealth'] = df['twealth2'] / df['xusd'] / 1000\ndf['gdptotal'] = df['gdptotal'] / df['xusd']\ndf['tincomeVAR'] = (df['tincome'] / df.groupby('country')['tincome'].shift(1) -1) * 100\ndf['twealthVAR'] = (df['twealth'] / df.groupby('country')['twealth'].shift(1) -1) * 100\ndf['wiratioVAR'] = (df['wiratio'] - df.groupby('country')['wiratio'].shift(1))\ndf = df[df['year'] == 2023]\ndf = df[df['wiratio'].notna() & df['tincome'].notna()]\ndf = pd.merge(df, df_countries, left_on='country', right_on='ISO2', how='inner')\ndf = df[['year', 'country', 'Country_Abr', 'gdptotal', 'tincome', 'twealth', 'wiratio', 'tincomeVAR', 'twealthVAR', 'wiratioVAR']]\ndf = df[(df['tincome'] &gt;= 0) & (df['tincome'] &lt;= 120000)]\ndf = df.sort_values(by='gdptotal', ascending=True)\ndf = df.rename(\n        columns={\n            'year': 'year',\n            'Country_Abr': 'country_name',\n            'gdptotal': 'total_income',\n            'tincome': 'incomeCY',\n            'twealth': 'wealthCY', \n            'wiratio': 'betaCY',\n            'tincomeVAR': 'incomeVAR',\n            'twealthVAR': 'wealthVAR',\n            'wiratioVAR': 'betaVAR'\n        }\n    )\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Crea la figura\nfig = go.Figure()\n\n# Marker size y line width calculados\nmarker_size = np.sqrt(df[\"total_income\"] / df[\"total_income\"].max()) * 100 + 3\nline_width  = np.sqrt(df[\"total_income\"] / df[\"total_income\"].max()) * 4 + 0.5\n\n# Primero agregamos los puntos del scatter\nfig.add_trace(go.Scatter(\n    x=df[\"betaCY\"],\n    y=df[\"incomeCY\"],\n    mode='markers',\n    text=df[\"country_name\"],\n    customdata=np.vstack((df[\"incomeCY\"], df[\"wealthCY\"], df[\"incomeVAR\"], df[\"wealthVAR\"], df[\"betaCY\"], df[\"betaVAR\"])).T,\n    marker=dict(\n        size=marker_size,\n        color=\"rgba(0,0,0,0)\",\n        line=dict(\n            width=line_width,\n            color='black'\n        )\n    ),\n    hovertemplate=\"&lt;b&gt;Country:&lt;/b&gt; %{text}&lt;br&gt;\" +\n                  \"&lt;b&gt;Income Avg ($):&lt;/b&gt; %{y:.0f}k | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[2]:.2f}%&lt;br&gt;\" + \n                  \"&lt;b&gt;Wealth Avg ($):&lt;/b&gt; %{customdata[1]:.0f}k | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[3]:.2f}%&lt;br&gt;\" +\n                  \"&lt;b&gt;Ratio:&lt;/b&gt; %{customdata[4]:.2f} | &lt;b&gt;Var. 1980:&lt;/b&gt; %{customdata[5]:.2f}pp&lt;extra&gt;&lt;/extra&gt;\",\n    showlegend=False\n))\n\n# Ahora agregamos las imágenes de las banderas\nfor i, row in df.iterrows():\n    country_iso = row[\"country\"]\n    \n    # Calcular tamaño de la imagen\n    image_size = marker_size[i] * 0.205\n\n    # Añadir la imagen de la bandera, asegurándose de que el orden es correcto\n    fig.add_layout_image(\n        dict(\n            source=f\"https://raw.githubusercontent.com/guillemmaya92/world_flags_round/refs/heads/master/flags/{country_iso}.png\",\n            xref=\"x\",\n            yref=\"y\",\n            xanchor=\"center\",\n            yanchor=\"middle\",\n            x=row[\"betaCY\"],\n            y=row[\"incomeCY\"],\n            sizex=image_size,\n            sizey=image_size,\n            sizing=\"contain\",\n            opacity=0.8\n        )\n    )\n\n# Add red and green shapes\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=0, x1=6,\n    y0=0, y1=1,\n    fillcolor=\"green\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=6, x1=12,\n    y0=0, y1=1,\n    fillcolor=\"red\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\n\n# Configuration plot\nfig.update_layout(\n    title=\"&lt;b&gt;Wealth-Income Ratio&lt;/b&gt;\",\n    title_x=0.11,\n    title_y=0.93,\n    title_font=dict(size=16),\n    annotations=[\n        dict(\n            text=\"Global Patterns in Wealth-Income Ratios and Average Income per Capita\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.06,\n            showarrow=False,\n            font=dict(size=11)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; World Inequality Database (WID)\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.12,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"&lt;b&gt;Currency:&lt;/b&gt; Official exchange rate {df[\"year\"].max()} of the local currency to USD.\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.14,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"&lt;i&gt;@guillemmaya&lt;/i&gt;\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=1,\n            y=-0.14,\n            showarrow=False,\n            font=dict(size=11),\n            align=\"right\"\n        ),\n        dict(\n            text=str(df[\"year\"].max()),\n            xref=\"paper\", \n            yref=\"paper\",\n            x=1, \n            y=1.08,\n            showarrow=False,\n            font=dict(size=22, color='lightgray', weight='bold'),\n            align=\"right\"\n        )\n    ],\n    xaxis=dict(\n        title=\"&lt;b&gt;Wealth-Income Ratio&lt;/b&gt;\",\n        range=[0, 12],\n        tickvals=[i *  4 / 2 for i in range(7)],\n        ticktext=[f\"{int(i * 4 / 2)}\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    yaxis=dict(\n        title=\"&lt;b&gt;Average Income per Capita ($US)&lt;/b&gt;\",\n        range=[0, 120],\n        tickvals=[i * 120 / 6 for i in range(7)],\n        ticktext=[f\"{int(i * 120 / 6)}k\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    height=750,\n    width=750,\n    plot_bgcolor=\"white\",   \n    paper_bgcolor=\"white\"\n)\n\n# Add a custom legend\nsize_legend = ['Smaller', 'Middle', 'Bigger']\nsize_values = [5, 10, 20]\n\nfor label, size in zip(size_legend, size_values):\n    fig.add_trace(go.Scatter(\n        x=[None],\n        y=[None],\n        mode='markers',\n        marker=dict(\n            size=size,\n            color=\"rgba(0,0,0,0)\",\n            line=dict(\n                width=1,\n                color='black'\n            )\n        ),\n        legendgroup='size',\n        showlegend=True,\n        name=f'{label}'\n    ))\n\nfig.update_layout(\n    legend=dict(\n        title=dict(text='&lt;b&gt;  Total Income&lt;/b&gt;'), \n        font=dict(size=11),\n        x=0.025,\n        y=0.95,\n        xanchor='left',\n        bgcolor='white',\n        bordercolor='black',\n        borderwidth=1\n    )\n)\n\n# Save as HTML file!\nfig.write_html(\"C:/Users/guill/Desktop/FIG_WID_CapitalisBack_Flag.html\")\nfig.write_image(\"C:/Users/guill/Desktop/FIG_WID_CapitalisBack_Flag.png\")\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/202510-globalization-eras/index.html",
    "href": "posts/202510-globalization-eras/index.html",
    "title": "Globalization Eras",
    "section": "",
    "text": "The chart illustrates the level of openness in global trade since the onset of globalization, with each period marked by unique economic conditions and distinct international relations.\n\n\nCode\n# Libraries\n# ============================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport wbgapi as wb\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Extraction Data OURWORLDINDATA\n# ============================================\n# Get data\ndfo = pd.read_csv(\"https://ourworldindata.org/grapher/globalization-over-5-centuries.csv?v=1&csvType=full&useColumnShortNames=true\", storage_options = {'User-Agent': 'Our World In Data data fetch/1.0'})\ndfo = dfo[dfo['Code'] == 'OWID_WRL']\n\n# Rename columns\ndfo = dfo.rename(columns={\n    'Year': 'year',\n    ' World trade based on Maddison (% of GDP) (Klasing and Milionis (2014)) ': 'trade_klasing',\n    'World trade based on own estimates (% of GDP) (Klasing and Milionis (2014)) ': 'trade_klasing_madisson',\n    'ne_trd_gnfs_zs': 'trade_penn',\n    'trade_openness': 'trade_openness_index'\n})\n\n# Trade priority data\ndfo = dfo[['year', 'trade_klasing', 'trade_klasing_madisson', 'trade_penn', 'trade_openness_index']]\ndfo['trade'] = np.where(dfo['trade_openness_index'].notnull(), dfo['trade_openness_index'], \n                        np.where(dfo['trade_penn'].notnull(), dfo['trade_penn'], \n                        np.where(dfo['trade_klasing_madisson'].notnull(), dfo['trade_klasing_madisson'], \n                        dfo['trade_klasing'])))\n\n# Prepare dfo\ndfo = dfo[['year', 'trade']]\ndfo = dfo[dfo['trade'].notnull()]\ndfo = dfo.sort_values(by='year').reset_index(drop=True)\n\n# Extraction Data COUNTRIES\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndfc = pd.DataFrame(data)\ndfc = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = dfc.rename(columns={'index': 'ISO3'})\n\n# Extraction Data WORLDBANK\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.MKTP.CD', 'NE.EXP.GNFS.CD', 'NE.IMP.GNFS.CD']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1970, 2024)\ndata = wb.data.DataFrame(indicator, 'WLD', data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndfw = data.rename(columns={\n    'time': 'year',\n    'economy': 'iso',\n    'NY.GDP.MKTP.CD': 'gdp',\n    'NE.EXP.GNFS.CD': 'exports',\n    'NE.IMP.GNFS.CD': 'imports'\n})\n\ndfw['comerce'] = dfw['imports'] + dfw['exports']\ndfw = dfw[['year', 'gdp', 'comerce']].groupby('year', as_index=False).sum()\ndfw['trade'] = dfw['comerce'] / dfw['gdp'] * 100\ndfw = dfw[['year', 'trade']]\n\n# Unify DF\n# ========================================================\n# Filter dataframes\ndfo = dfo[dfo['year'] &lt; 1970]\ndfw = dfw[dfw['year'] &gt; 1970]\n\n# Filter dataframes\ndf = pd.concat([dfo, dfw], ignore_index=True)\n\n# Divide dataframes\ndf_1870_1914 = df[(df['year'] &gt;= 1870) & (df['year'] &lt;= 1915)]\ndf_1915_1945 = df[(df['year'] &gt;= 1915) & (df['year'] &lt;= 1945)]\ndf_1945_1980 = df[(df['year'] &gt;= 1945) & (df['year'] &lt;= 1980)]\ndf_1980_2008 = df[(df['year'] &gt;= 1980) & (df['year'] &lt;= 2008)]\ndf_2008_2023 = df[(df['year'] &gt;= 2008) & (df['year'] &lt;= 2023)]\n\nprint(df)\n\n# Visualization Data\n# ============================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Create a figure\nax = plt.figure(figsize=(10, 6))\n\n# Stackplot for each dataframe\nplt.stackplot(df_1870_1914['year'], df_1870_1914['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_1915_1945['year'], df_1915_1945['trade'], color='#d92724', alpha=1)\nplt.stackplot(df_1945_1980['year'], df_1945_1980['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_1980_2008['year'], df_1980_2008['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_2008_2023['year'], df_2008_2023['trade'], color='#d92724', alpha=1)\n\n# Add vertical lines\nplt.axvline(x=1915, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=1945, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=1980, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=2008, color='white', linestyle='--', linewidth=0.75)\n\n# Add title and labels\nplt.text(0, 1.08, f'Eras of globalization', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.045, 'Trade openess slowed following the global financial crisis.', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.01, '(sum of exports and imports as percent of GDP)', fontsize=9, fontweight='light', color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlim(1871, 2023)\nplt.ylim(0, 65)\nplt.xticks([1870, 1915, 1945, 1980, 2008])\nplt.gca().yaxis.grid(True, linestyle='-', alpha=0.4)\n\n# Delete spines\nfor spine in [\"top\", \"left\", \"right\"]:\n    plt.gca().spines[spine].set_visible(False)\n\n# Industrialization\nplt.text(\n    x=df_1870_1914['year'].mean(),\n    y=3,\n    s=\"1870-1914\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1870_1914['year'].mean(),\n    y=1,\n    s=\"Industrialization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Wars and proteccionism\nplt.text(\n    x=df_1915_1945['year'].mean(),\n    y=3,\n    s=\"1915-1945\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1915_1945['year'].mean(),\n    y=1,\n    s=\"Wars, proteccionism\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Fixed exchanges rates\nplt.text(\n    x=df_1945_1980['year'].mean(),\n    y=3,\n    s=\"1945-1980\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1945_1980['year'].mean(),\n    y=1,\n    s=\"Fixed exchanges rates\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Liberization\nplt.text(\n    x=df_1980_2008['year'].mean(),\n    y=3,\n    s=\"1980-2008\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1980_2008['year'].mean(),\n    y=1,\n    s=\"Liberization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Slowbalization\nplt.text(\n    x=df_2008_2023['year'].mean() +2,\n    y=3,\n    s=\"2008-current\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom',\n    rotation=90\n)\nplt.text(\n    x=df_2008_2023['year'].mean() +5,\n    y=1,\n    s=\"Slowbalization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom',\n    rotation=90\n)\n\n# Add Data Source\nplt.text(0, -0.12, 'Data Source: PIIE, Jorda-Schularick-Taylor Macrohistory Database, Penn World Data (10.0), World Bank, and IMF staff calculations.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Show plot!\nplt.show()"
  },
  {
    "objectID": "posts/202510-globalization-eras/index.html#summary",
    "href": "posts/202510-globalization-eras/index.html#summary",
    "title": "Globalization Eras",
    "section": "",
    "text": "The chart illustrates the level of openness in global trade since the onset of globalization, with each period marked by unique economic conditions and distinct international relations.\n\n\nCode\n# Libraries\n# ============================================\nimport pandas as pd\nimport numpy as np\nimport requests\nimport wbgapi as wb\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# Extraction Data OURWORLDINDATA\n# ============================================\n# Get data\ndfo = pd.read_csv(\"https://ourworldindata.org/grapher/globalization-over-5-centuries.csv?v=1&csvType=full&useColumnShortNames=true\", storage_options = {'User-Agent': 'Our World In Data data fetch/1.0'})\ndfo = dfo[dfo['Code'] == 'OWID_WRL']\n\n# Rename columns\ndfo = dfo.rename(columns={\n    'Year': 'year',\n    ' World trade based on Maddison (% of GDP) (Klasing and Milionis (2014)) ': 'trade_klasing',\n    'World trade based on own estimates (% of GDP) (Klasing and Milionis (2014)) ': 'trade_klasing_madisson',\n    'ne_trd_gnfs_zs': 'trade_penn',\n    'trade_openness': 'trade_openness_index'\n})\n\n# Trade priority data\ndfo = dfo[['year', 'trade_klasing', 'trade_klasing_madisson', 'trade_penn', 'trade_openness_index']]\ndfo['trade'] = np.where(dfo['trade_openness_index'].notnull(), dfo['trade_openness_index'], \n                        np.where(dfo['trade_penn'].notnull(), dfo['trade_penn'], \n                        np.where(dfo['trade_klasing_madisson'].notnull(), dfo['trade_klasing_madisson'], \n                        dfo['trade_klasing'])))\n\n# Prepare dfo\ndfo = dfo[['year', 'trade']]\ndfo = dfo[dfo['trade'].notnull()]\ndfo = dfo.sort_values(by='year').reset_index(drop=True)\n\n# Extraction Data COUNTRIES\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndfc = pd.DataFrame(data)\ndfc = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = dfc.rename(columns={'index': 'ISO3'})\n\n# Extraction Data WORLDBANK\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.MKTP.CD', 'NE.EXP.GNFS.CD', 'NE.IMP.GNFS.CD']\ncountries = df_countries['ISO3'].tolist()\ndata_range = range(1970, 2024)\ndata = wb.data.DataFrame(indicator, 'WLD', data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndfw = data.rename(columns={\n    'time': 'year',\n    'economy': 'iso',\n    'NY.GDP.MKTP.CD': 'gdp',\n    'NE.EXP.GNFS.CD': 'exports',\n    'NE.IMP.GNFS.CD': 'imports'\n})\n\ndfw['comerce'] = dfw['imports'] + dfw['exports']\ndfw = dfw[['year', 'gdp', 'comerce']].groupby('year', as_index=False).sum()\ndfw['trade'] = dfw['comerce'] / dfw['gdp'] * 100\ndfw = dfw[['year', 'trade']]\n\n# Unify DF\n# ========================================================\n# Filter dataframes\ndfo = dfo[dfo['year'] &lt; 1970]\ndfw = dfw[dfw['year'] &gt; 1970]\n\n# Filter dataframes\ndf = pd.concat([dfo, dfw], ignore_index=True)\n\n# Divide dataframes\ndf_1870_1914 = df[(df['year'] &gt;= 1870) & (df['year'] &lt;= 1915)]\ndf_1915_1945 = df[(df['year'] &gt;= 1915) & (df['year'] &lt;= 1945)]\ndf_1945_1980 = df[(df['year'] &gt;= 1945) & (df['year'] &lt;= 1980)]\ndf_1980_2008 = df[(df['year'] &gt;= 1980) & (df['year'] &lt;= 2008)]\ndf_2008_2023 = df[(df['year'] &gt;= 2008) & (df['year'] &lt;= 2023)]\n\nprint(df)\n\n# Visualization Data\n# ============================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Create a figure\nax = plt.figure(figsize=(10, 6))\n\n# Stackplot for each dataframe\nplt.stackplot(df_1870_1914['year'], df_1870_1914['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_1915_1945['year'], df_1915_1945['trade'], color='#d92724', alpha=1)\nplt.stackplot(df_1945_1980['year'], df_1945_1980['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_1980_2008['year'], df_1980_2008['trade'], color='#084d95', alpha=1)\nplt.stackplot(df_2008_2023['year'], df_2008_2023['trade'], color='#d92724', alpha=1)\n\n# Add vertical lines\nplt.axvline(x=1915, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=1945, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=1980, color='white', linestyle='--', linewidth=0.75)\nplt.axvline(x=2008, color='white', linestyle='--', linewidth=0.75)\n\n# Add title and labels\nplt.text(0, 1.08, f'Eras of globalization', fontsize=16, fontweight='bold', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.045, 'Trade openess slowed following the global financial crisis.', fontsize=11, color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.text(0, 1.01, '(sum of exports and imports as percent of GDP)', fontsize=9, fontweight='light', color='#262626', ha='left', transform=plt.gca().transAxes)\nplt.xlim(1871, 2023)\nplt.ylim(0, 65)\nplt.xticks([1870, 1915, 1945, 1980, 2008])\nplt.gca().yaxis.grid(True, linestyle='-', alpha=0.4)\n\n# Delete spines\nfor spine in [\"top\", \"left\", \"right\"]:\n    plt.gca().spines[spine].set_visible(False)\n\n# Industrialization\nplt.text(\n    x=df_1870_1914['year'].mean(),\n    y=3,\n    s=\"1870-1914\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1870_1914['year'].mean(),\n    y=1,\n    s=\"Industrialization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Wars and proteccionism\nplt.text(\n    x=df_1915_1945['year'].mean(),\n    y=3,\n    s=\"1915-1945\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1915_1945['year'].mean(),\n    y=1,\n    s=\"Wars, proteccionism\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Fixed exchanges rates\nplt.text(\n    x=df_1945_1980['year'].mean(),\n    y=3,\n    s=\"1945-1980\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1945_1980['year'].mean(),\n    y=1,\n    s=\"Fixed exchanges rates\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Liberization\nplt.text(\n    x=df_1980_2008['year'].mean(),\n    y=3,\n    s=\"1980-2008\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom'\n)\nplt.text(\n    x=df_1980_2008['year'].mean(),\n    y=1,\n    s=\"Liberization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom'\n)\n\n# Slowbalization\nplt.text(\n    x=df_2008_2023['year'].mean() +2,\n    y=3,\n    s=\"2008-current\",\n    fontsize=9, \n    color='white',\n    ha='center',\n    va='bottom',\n    rotation=90\n)\nplt.text(\n    x=df_2008_2023['year'].mean() +5,\n    y=1,\n    s=\"Slowbalization\",\n    fontsize=9, \n    fontweight='bold',\n    color='white',\n    ha='center',\n    va='bottom',\n    rotation=90\n)\n\n# Add Data Source\nplt.text(0, -0.12, 'Data Source: PIIE, Jorda-Schularick-Taylor Macrohistory Database, Penn World Data (10.0), World Bank, and IMF staff calculations.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Show plot!\nplt.show()"
  },
  {
    "objectID": "posts/202511-gdpc-global-north/index.html",
    "href": "posts/202511-gdpc-global-north/index.html",
    "title": "Global North: Inequalities in GDP per Capita",
    "section": "",
    "text": "Absolute inequalities in GDP per capita between the Global North and other regions of the world highlight the significant economic divide that persists globally. These disparities emphasize the concrete differences in wealth, living standards, and access to essential resources, underscoring the structural imbalance in global development.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.KD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = ['1960', '2023']\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'year',\n    'SP.POP.TOTL': 'pop',\n    'NY.GDP.PCAP.KD': 'gdpc'\n})\n\n# Filter nulls and create total\ndf_wb = df_wb[~df_wb['gdpc'].isna()]\ndf_wb['gdpt'] = df_wb['gdpc'] * df_wb['pop']\n\n# Data Manipulation\n# =====================================================================\n# Merge queries\ndf = df_wb.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['Analytical2', 'year', 'pop', 'gdpt']]\ndf = df.rename(columns={'Analytical2': 'group'})\ndf = df[df['group'].notna()]\n\n# Summarizing Groups\ndfg = df.copy()\ndfg['group'] = np.where(dfg['group'] == 'Global North', 'Global North', 'Rest World')\ndfg = dfg.groupby(['group', 'year'])[['pop', 'gdpt']].sum().reset_index()\ndfg['gdpc'] = dfg['gdpt'] / dfg['pop']\ndfg['gdpcdif'] = dfg['gdpc'] - dfg.groupby('group')['gdpc'].shift()\n\n# Summarizing Analytical\ndf = df.groupby(['group', 'year'])[['pop', 'gdpt']].sum().reset_index()\ndf['gdpc'] = df['gdpt'] / df['pop']\n\n# Porcentual\ndf['pop%'] = df['pop'] / df.groupby('year')['pop'].transform('sum')\n\ndf = df.sort_values(by=['pop%', 'year'], ascending=[False, True])\n\n# Data Visualization\n# =====================================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Filter dataframes\ndf_1960 = df[df['year'] == 1960]\ndf_2023 = df[df['year'] == 2023]\n\n# Values\nrw60 = dfg.loc[(dfg['group'] == 'Rest World') & (dfg['year'] == 1960), 'gdpc'].values[0]\ngn60 = dfg.loc[(dfg['group'] == 'Global North') & (dfg['year'] == 1960), 'gdpc'].values[0]\nrw23 = dfg.loc[(dfg['group'] == 'Rest World') & (dfg['year'] == 2023), 'gdpc'].values[0]\ngn23 = dfg.loc[(dfg['group'] == 'Global North') & (dfg['year'] == 2023), 'gdpc'].values[0]\n\n# Colors\ngroup_colors = {\n    'East Asia & Pacific': '#4D93D9',\n    'Eastern Europe & Central Asia': '#00B050',\n    'Global North': '#808080',\n    'Latin America and the Caribbean': '#C00000',\n    'Middle East & North Africa': '#F1A983',\n    'South Asia': '#FFC000',\n    'Sub-Saharan Africa': '#7030A0'\n}\n\n# Define ticks\nxticks = np.linspace(0, 50000, 5)\n\n# Create figure and suplots\nfig, axes = plt.subplots(2, 1, figsize=(12, 5))\n\n# First plot (1960)\naxes[0].scatter(df_1960['gdpc'], df_1960['year'], s=df_1960['pop%'] * 12000, alpha=0.4, c=df_1960['group'].map(group_colors), edgecolors='w')\naxes[0].set_yticks([1960])\naxes[0].set_xlim(0, 50000)\naxes[0].set_xticks(xticks)\naxes[0].xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: f'{x:,.0f}'))\naxes[0].axvline(x=rw60, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {rw60}')\naxes[0].axvline(x=gn60, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {gn60}')\naxes[0].text(rw60 +2500, 1960 + 70, f'{rw60:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[0].text(gn60 +1800, 1960 + 70, f'{gn60:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[0].text((gn60-rw60)/2+rw60, 1960 + 50, f'GAP \\n{gn60-rw60:,.0f}$', color='#373737', fontsize=8, fontweight='bold', \n             va='bottom', ha='center', rotation=0)\naxes[0].text((gn60-rw60)/2+rw60, 1960 + 25, f'+{(gn60-rw60)/rw60*100:,.0f}%', color='#12330b', fontsize=8, \n             va='bottom', ha='center', rotation=0)\n\n# Second plot (2023)\naxes[1].scatter(df_2023['gdpc'], df_2023['year'], s=df_2023['pop%'] * 12000, alpha=0.4, c=df_2023['group'].map(group_colors), edgecolors='w')\naxes[1].set_xlabel('GDP per capita ($US constant 2015)', fontsize=10, fontweight='bold')\naxes[1].set_yticks([2023])\naxes[1].set_xlim(0, 50000) \naxes[1].set_xticks(xticks)\naxes[1].xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: f'{x:,.0f}'))\naxes[1].axvline(x=rw23, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {rw23}')\naxes[1].axvline(x=gn23, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {gn23}')\naxes[1].text(rw23 +1800, 2023 + 70, f'{rw23:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[1].text(gn23 +1800, 2023 + 70, f'{gn23:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[1].text((gn23-rw23)/2+rw23, 2023 + 50, f'GAP \\n{gn23-rw23:,.0f}$', color='#373737', fontsize=8, fontweight='bold', \n             va='bottom', ha='center', rotation=0)\naxes[1].text((gn23-rw23)/2+rw23, 2023 + 25, f'+{(gn23-rw23)/rw23*100:,.0f}%', color='#12330b', fontsize=8, \n             va='bottom', ha='center', rotation=0)\n\n# Configuration\nyticklabels_1960 = axes[0].get_yticklabels()\nyticklabels_1960[0].set_fontweight('bold')\nyticklabels_1960[0].set_fontsize(14)\nyticklabels_1960[0].set_color('darkgrey')\naxes[0].set_yticklabels(yticklabels_1960)\n\nyticklabels_2023 = axes[1].get_yticklabels()\nyticklabels_2023[0].set_fontweight('bold')\nyticklabels_2023[0].set_fontsize(14)\nyticklabels_2023[0].set_color('darkgrey')\naxes[1].set_yticklabels(yticklabels_2023)\n\n# Grid and labels\naxes[0].text(0, 1.25, 'Global Inequalities in GDP per Capita', fontsize=13, fontweight='bold', ha='left', transform=axes[0].transAxes)\naxes[0].text(0, 1.1, 'Evolution by region from 1960 to 2023', fontsize=9, color='#262626', ha='left', transform=axes[0].transAxes)\n\n# Add custom legend\nhandles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10) \n           for color in group_colors.values()]\n\nlabels = list(group_colors.keys())\n\nlegend = axes[0].legend(handles, labels, title=\"Regions\", bbox_to_anchor=(1.05, 0.5), loc='upper left', \n                        frameon=False, fontsize='8', title_fontsize='10')\n\nplt.setp(legend.get_title(), fontweight='bold')\n\n# Add Data Source\naxes[1].text(0, -0.5, 'Data Source: World Bank.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Add Notes\naxes[1].text(0, -0.6, 'Notes: The size corresponds to the percentage of the total population.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Add Global North\naxes[1].text(0, -0.7, 'Global North: US, European Union, Canada, Australia, New Zealand, Russia, Switzerland, Iceland, Israel, Greenland, Norway, Japan', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Adjusting plot...\nplt.tight_layout()\n\nplt.savefig(\"C:/Users/guill/Downloads/FIG_WORLDBANK_Global_North.png\", dpi=300, bbox_inches='tight') \n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202511-gdpc-global-north/index.html#summary",
    "href": "posts/202511-gdpc-global-north/index.html#summary",
    "title": "Global North: Inequalities in GDP per Capita",
    "section": "",
    "text": "Absolute inequalities in GDP per capita between the Global North and other regions of the world highlight the significant economic divide that persists globally. These disparities emphasize the concrete differences in wealth, living standards, and access to essential resources, underscoring the structural imbalance in global development.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport wbgapi as wb\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - WBD (1960-1980)\n# ========================================================\n# To use the built-in plotting method\nindicator = ['NY.GDP.PCAP.KD', 'SP.POP.TOTL']\ncountries = df_countries['ISO3'].tolist()\ndata_range = ['1960', '2023']\ndata = wb.data.DataFrame(indicator, countries, data_range, numericTimeKeys=True, labels=False, columns='series').reset_index()\ndf_wb = data.rename(columns={\n    'economy': 'ISO3',\n    'time': 'year',\n    'SP.POP.TOTL': 'pop',\n    'NY.GDP.PCAP.KD': 'gdpc'\n})\n\n# Filter nulls and create total\ndf_wb = df_wb[~df_wb['gdpc'].isna()]\ndf_wb['gdpt'] = df_wb['gdpc'] * df_wb['pop']\n\n# Data Manipulation\n# =====================================================================\n# Merge queries\ndf = df_wb.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['Analytical2', 'year', 'pop', 'gdpt']]\ndf = df.rename(columns={'Analytical2': 'group'})\ndf = df[df['group'].notna()]\n\n# Summarizing Groups\ndfg = df.copy()\ndfg['group'] = np.where(dfg['group'] == 'Global North', 'Global North', 'Rest World')\ndfg = dfg.groupby(['group', 'year'])[['pop', 'gdpt']].sum().reset_index()\ndfg['gdpc'] = dfg['gdpt'] / dfg['pop']\ndfg['gdpcdif'] = dfg['gdpc'] - dfg.groupby('group')['gdpc'].shift()\n\n# Summarizing Analytical\ndf = df.groupby(['group', 'year'])[['pop', 'gdpt']].sum().reset_index()\ndf['gdpc'] = df['gdpt'] / df['pop']\n\n# Porcentual\ndf['pop%'] = df['pop'] / df.groupby('year')['pop'].transform('sum')\n\ndf = df.sort_values(by=['pop%', 'year'], ascending=[False, True])\n\n# Data Visualization\n# =====================================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Filter dataframes\ndf_1960 = df[df['year'] == 1960]\ndf_2023 = df[df['year'] == 2023]\n\n# Values\nrw60 = dfg.loc[(dfg['group'] == 'Rest World') & (dfg['year'] == 1960), 'gdpc'].values[0]\ngn60 = dfg.loc[(dfg['group'] == 'Global North') & (dfg['year'] == 1960), 'gdpc'].values[0]\nrw23 = dfg.loc[(dfg['group'] == 'Rest World') & (dfg['year'] == 2023), 'gdpc'].values[0]\ngn23 = dfg.loc[(dfg['group'] == 'Global North') & (dfg['year'] == 2023), 'gdpc'].values[0]\n\n# Colors\ngroup_colors = {\n    'East Asia & Pacific': '#4D93D9',\n    'Eastern Europe & Central Asia': '#00B050',\n    'Global North': '#808080',\n    'Latin America and the Caribbean': '#C00000',\n    'Middle East & North Africa': '#F1A983',\n    'South Asia': '#FFC000',\n    'Sub-Saharan Africa': '#7030A0'\n}\n\n# Define ticks\nxticks = np.linspace(0, 50000, 5)\n\n# Create figure and suplots\nfig, axes = plt.subplots(2, 1, figsize=(12, 5))\n\n# First plot (1960)\naxes[0].scatter(df_1960['gdpc'], df_1960['year'], s=df_1960['pop%'] * 12000, alpha=0.4, c=df_1960['group'].map(group_colors), edgecolors='w')\naxes[0].set_yticks([1960])\naxes[0].set_xlim(0, 50000)\naxes[0].set_xticks(xticks)\naxes[0].xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: f'{x:,.0f}'))\naxes[0].axvline(x=rw60, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {rw60}')\naxes[0].axvline(x=gn60, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {gn60}')\naxes[0].text(rw60 +2500, 1960 + 70, f'{rw60:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[0].text(gn60 +1800, 1960 + 70, f'{gn60:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[0].text((gn60-rw60)/2+rw60, 1960 + 50, f'GAP \\n{gn60-rw60:,.0f}$', color='#373737', fontsize=8, fontweight='bold', \n             va='bottom', ha='center', rotation=0)\naxes[0].text((gn60-rw60)/2+rw60, 1960 + 25, f'+{(gn60-rw60)/rw60*100:,.0f}%', color='#12330b', fontsize=8, \n             va='bottom', ha='center', rotation=0)\n\n# Second plot (2023)\naxes[1].scatter(df_2023['gdpc'], df_2023['year'], s=df_2023['pop%'] * 12000, alpha=0.4, c=df_2023['group'].map(group_colors), edgecolors='w')\naxes[1].set_xlabel('GDP per capita ($US constant 2015)', fontsize=10, fontweight='bold')\naxes[1].set_yticks([2023])\naxes[1].set_xlim(0, 50000) \naxes[1].set_xticks(xticks)\naxes[1].xaxis.set_major_formatter(ticker.FuncFormatter(lambda x, pos: f'{x:,.0f}'))\naxes[1].axvline(x=rw23, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {rw23}')\naxes[1].axvline(x=gn23, color='darkred', linewidth=0.5, linestyle='--', label=f'GDPC Global North 1960: {gn23}')\naxes[1].text(rw23 +1800, 2023 + 70, f'{rw23:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[1].text(gn23 +1800, 2023 + 70, f'{gn23:,.0f}$', color='darkred', fontsize=8, \n             va='bottom', ha='center', rotation=0)\naxes[1].text((gn23-rw23)/2+rw23, 2023 + 50, f'GAP \\n{gn23-rw23:,.0f}$', color='#373737', fontsize=8, fontweight='bold', \n             va='bottom', ha='center', rotation=0)\naxes[1].text((gn23-rw23)/2+rw23, 2023 + 25, f'+{(gn23-rw23)/rw23*100:,.0f}%', color='#12330b', fontsize=8, \n             va='bottom', ha='center', rotation=0)\n\n# Configuration\nyticklabels_1960 = axes[0].get_yticklabels()\nyticklabels_1960[0].set_fontweight('bold')\nyticklabels_1960[0].set_fontsize(14)\nyticklabels_1960[0].set_color('darkgrey')\naxes[0].set_yticklabels(yticklabels_1960)\n\nyticklabels_2023 = axes[1].get_yticklabels()\nyticklabels_2023[0].set_fontweight('bold')\nyticklabels_2023[0].set_fontsize(14)\nyticklabels_2023[0].set_color('darkgrey')\naxes[1].set_yticklabels(yticklabels_2023)\n\n# Grid and labels\naxes[0].text(0, 1.25, 'Global Inequalities in GDP per Capita', fontsize=13, fontweight='bold', ha='left', transform=axes[0].transAxes)\naxes[0].text(0, 1.1, 'Evolution by region from 1960 to 2023', fontsize=9, color='#262626', ha='left', transform=axes[0].transAxes)\n\n# Add custom legend\nhandles = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor=color, markersize=10) \n           for color in group_colors.values()]\n\nlabels = list(group_colors.keys())\n\nlegend = axes[0].legend(handles, labels, title=\"Regions\", bbox_to_anchor=(1.05, 0.5), loc='upper left', \n                        frameon=False, fontsize='8', title_fontsize='10')\n\nplt.setp(legend.get_title(), fontweight='bold')\n\n# Add Data Source\naxes[1].text(0, -0.5, 'Data Source: World Bank.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Add Notes\naxes[1].text(0, -0.6, 'Notes: The size corresponds to the percentage of the total population.', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Add Global North\naxes[1].text(0, -0.7, 'Global North: US, European Union, Canada, Australia, New Zealand, Russia, Switzerland, Iceland, Israel, Greenland, Norway, Japan', \n    transform=plt.gca().transAxes, \n    fontsize=8, \n    color='gray')\n\n# Adjusting plot...\nplt.tight_layout()\n\nplt.savefig(\"C:/Users/guill/Downloads/FIG_WORLDBANK_Global_North.png\", dpi=300, bbox_inches='tight') \n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/202512-temperature-anomalies/index.html",
    "href": "posts/202512-temperature-anomalies/index.html",
    "title": "Global temperature anomalies",
    "section": "",
    "text": "Global temperature anomalies indicate how Earth’s surface temperature deviates from a historical average, providing crucial insights into climate change. Persistent positive anomalies signal a warming trend driven by greenhouse gas emissions, while negative anomalies are less frequent in recent decades. By tracking these variations, scientists can assess long-term climate patterns, identify extreme weather risks, and evaluate the impact of human activities on global temperatures.\n\n\nCode\n# Libraries\n# =========================================\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib.ticker as ticker\n\n# Data Extraction (temperature)\n# =========================================\n# URL NASA GISS global temperature\nurl = \"https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv\"\ndft = pd.read_csv(url, skiprows=1)\n\n# Data Extraction (co2)\n# =========================================\n# URL del archivo CSV\nurl = \"https://zenodo.org/records/13981696/files/GCB2024v17_MtCO2_flat.csv?download=1\"\ndfc = pd.read_csv(url)\n\n# Data Manipulation (temperature)\n# =========================================\n# Select columns\ndft = dft[[\"Year\", \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"J-D\"]]\n\n# Rename columns\ndft.columns = dft.columns.str.lower()\ndft = dft.rename(columns=lambda x: x.lower())\n\n# Unpivot columns\ndft = dft.melt(id_vars=[\"year\"], var_name=\"month\", value_name=\"value\")\ndft = dft[dft[\"month\"] == \"j-d\"]\n\n# Data Manipulation (co2)\n# =========================================\n# Transform Data\ndfc = dfc[dfc['ISO 3166-1 alpha-3'] == 'WLD']\ndfc.rename(columns={'Year': 'year', 'ISO 3166-1 alpha-3': 'iso', 'Total': 'co2'}, inplace=True)\ndfc = dfc[['year', 'iso', 'co2']]\n\n# Merge dataframes\n# =========================================\ndf = dft.merge(dfc, on='year', how='left')\n\nprint(df)\n\n# Data Visualization\n# =========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Define a color map\ncmap = plt.get_cmap('coolwarm')\nnorm = plt.Normalize(-0.5, 1)\n\n# Create figure and plot\nfig, ax1 = plt.subplots(figsize=(10, 5))\nax2 = ax1.twinx()\nbars =ax1.bar(df['year'], df['value'], color=cmap(norm(df['value'])), width=1, edgecolor='none')\nline = ax2.plot(df['year'], df['co2'], label='CO2', color='#262626', linestyle=':', linewidth=1)\n\n# Add title and labels\nax1.text(0, 1.12, f'Global Temperature Anomaly', fontsize=16, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.07, 'Compared with mid -20th century (°C)', fontsize=11, color='#262626', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.02, r'(In contrast with CO$_2$ emissions)', fontsize=9, fontweight='light', color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlim(1877, 2027)\nax1.axhline(y=0, color='black', linestyle='-', linewidth=0.75)\nyticks = [-0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25]\nytick_labels = [f'{y:+.2f}' if y != 0 else '0' for y in yticks]\nax1.set_yticks(yticks, ytick_labels)\nax1.set_yticklabels(ytick_labels, fontsize=9)\nax1.set_xticks([1880, 1890, 1900, 1910, 1920, 1930, 1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020])\nax1.tick_params(axis='x', labelsize=9)\nax1.yaxis.set_ticks_position('none')\nax1.grid(axis='y', linestyle='-', color='#262626', linewidth=0.1, alpha=0.6)\nax2.set_ylim(0, 40000)\nymin, ymax = ax2.get_ylim()\nyticks = np.linspace(ymin, ymax, 8)\nax2.set_yticks(yticks)\nyticks_rounded = np.round(yticks / 5000) * 5000\nyticks_k = [f\"{int(tick / 1000)}Mt\" for tick in yticks_rounded]\nax2.set_yticklabels(yticks_k)\nax2.tick_params(axis='y', labelsize=9)\nax2.yaxis.set_ticks_position('none')\n\n# Add column labels\nfor i, year in enumerate(df['year']):\n    if year in [1973, 1990, 1998, 2010, 2016, 2024]:\n        # Check positive and negative values\n        symbol = \"+\" if df['value'].iloc[i] &gt;= 0 else \"-\"\n        value_text = f\"{symbol}{abs(df['value'].iloc[i]):,.2f}\"\n        \n        # Recent value bold\n        fontweight = 'bold' if year == df['year'].max() else 'normal'\n\n        # Set the offset based on the year\n        offset = 0.11 if year in [1973, 1990] else 0.05\n\n        # Add label\n        ax1.text(year, df['value'].iloc[i] + offset, value_text,\n                 ha='center', va='bottom', fontsize=7, color='#363636', fontweight=fontweight)\n\n# Remove spines\nfor ax in [ax1, ax2]:\n    for spine in [\"top\", \"bottom\"]:\n        ax.spines[spine].set_visible(False)\n\n# Add Data Source\nspaces = ' ' * 23\nax1.text(0, -0.16, f'{spaces}NASA Goddard Institute for Space Studies\\nThe Global Carbon Project\\'s fossil CO₂ emissions dataset', \n         transform=ax1.transAxes, \n         fontsize=8, \n         color='gray', \n         ha='left', \n         family='sans-serif')\n\n# Add Data Source bold\nax1.text(0, -0.16, 'Data Source:\\n ', \n         transform=ax1.transAxes, \n         fontsize=8, \n         color='gray', \n         ha='left', \n         family='sans-serif', \n         fontweight='bold')\n\n # Add Year label\nformatted_date = 2024 \nax1.text(1, 1.12, f'{formatted_date}',\n    transform=ax1.transAxes, \n    fontsize=18, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Celsius\nax1.text(-0.04, -0.08, '°C', \n    transform=ax1.transAxes, \n    fontsize=10, \n    fontweight='bold',\n    color='black')\n\n# Add CO2\nax1.text(1.01, -0.08, r'CO$_2$', \n    transform=ax1.transAxes, \n    fontsize=10, \n    fontweight='bold',\n    color='black')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it..\nplt.savefig('C:/Users/guill/Downloads/FIG_NASA_Temperature_Anomalies.png', format='png', bbox_inches='tight')\n\n# Show the plot!\nplt.show()"
  },
  {
    "objectID": "posts/202512-temperature-anomalies/index.html#summary",
    "href": "posts/202512-temperature-anomalies/index.html#summary",
    "title": "Global temperature anomalies",
    "section": "",
    "text": "Global temperature anomalies indicate how Earth’s surface temperature deviates from a historical average, providing crucial insights into climate change. Persistent positive anomalies signal a warming trend driven by greenhouse gas emissions, while negative anomalies are less frequent in recent decades. By tracking these variations, scientists can assess long-term climate patterns, identify extreme weather risks, and evaluate the impact of human activities on global temperatures.\n\n\nCode\n# Libraries\n# =========================================\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib.ticker as ticker\n\n# Data Extraction (temperature)\n# =========================================\n# URL NASA GISS global temperature\nurl = \"https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv\"\ndft = pd.read_csv(url, skiprows=1)\n\n# Data Extraction (co2)\n# =========================================\n# URL del archivo CSV\nurl = \"https://zenodo.org/records/13981696/files/GCB2024v17_MtCO2_flat.csv?download=1\"\ndfc = pd.read_csv(url)\n\n# Data Manipulation (temperature)\n# =========================================\n# Select columns\ndft = dft[[\"Year\", \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", \"J-D\"]]\n\n# Rename columns\ndft.columns = dft.columns.str.lower()\ndft = dft.rename(columns=lambda x: x.lower())\n\n# Unpivot columns\ndft = dft.melt(id_vars=[\"year\"], var_name=\"month\", value_name=\"value\")\ndft = dft[dft[\"month\"] == \"j-d\"]\n\n# Data Manipulation (co2)\n# =========================================\n# Transform Data\ndfc = dfc[dfc['ISO 3166-1 alpha-3'] == 'WLD']\ndfc.rename(columns={'Year': 'year', 'ISO 3166-1 alpha-3': 'iso', 'Total': 'co2'}, inplace=True)\ndfc = dfc[['year', 'iso', 'co2']]\n\n# Merge dataframes\n# =========================================\ndf = dft.merge(dfc, on='year', how='left')\n\nprint(df)\n\n# Data Visualization\n# =========================================\n# Font and style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 9})\nsns.set(style=\"white\", palette=\"muted\")\n\n# Define a color map\ncmap = plt.get_cmap('coolwarm')\nnorm = plt.Normalize(-0.5, 1)\n\n# Create figure and plot\nfig, ax1 = plt.subplots(figsize=(10, 5))\nax2 = ax1.twinx()\nbars =ax1.bar(df['year'], df['value'], color=cmap(norm(df['value'])), width=1, edgecolor='none')\nline = ax2.plot(df['year'], df['co2'], label='CO2', color='#262626', linestyle=':', linewidth=1)\n\n# Add title and labels\nax1.text(0, 1.12, f'Global Temperature Anomaly', fontsize=16, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.07, 'Compared with mid -20th century (°C)', fontsize=11, color='#262626', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.02, r'(In contrast with CO$_2$ emissions)', fontsize=9, fontweight='light', color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlim(1877, 2027)\nax1.axhline(y=0, color='black', linestyle='-', linewidth=0.75)\nyticks = [-0.5, -0.25, 0, 0.25, 0.5, 0.75, 1, 1.25]\nytick_labels = [f'{y:+.2f}' if y != 0 else '0' for y in yticks]\nax1.set_yticks(yticks, ytick_labels)\nax1.set_yticklabels(ytick_labels, fontsize=9)\nax1.set_xticks([1880, 1890, 1900, 1910, 1920, 1930, 1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020])\nax1.tick_params(axis='x', labelsize=9)\nax1.yaxis.set_ticks_position('none')\nax1.grid(axis='y', linestyle='-', color='#262626', linewidth=0.1, alpha=0.6)\nax2.set_ylim(0, 40000)\nymin, ymax = ax2.get_ylim()\nyticks = np.linspace(ymin, ymax, 8)\nax2.set_yticks(yticks)\nyticks_rounded = np.round(yticks / 5000) * 5000\nyticks_k = [f\"{int(tick / 1000)}Mt\" for tick in yticks_rounded]\nax2.set_yticklabels(yticks_k)\nax2.tick_params(axis='y', labelsize=9)\nax2.yaxis.set_ticks_position('none')\n\n# Add column labels\nfor i, year in enumerate(df['year']):\n    if year in [1973, 1990, 1998, 2010, 2016, 2024]:\n        # Check positive and negative values\n        symbol = \"+\" if df['value'].iloc[i] &gt;= 0 else \"-\"\n        value_text = f\"{symbol}{abs(df['value'].iloc[i]):,.2f}\"\n        \n        # Recent value bold\n        fontweight = 'bold' if year == df['year'].max() else 'normal'\n\n        # Set the offset based on the year\n        offset = 0.11 if year in [1973, 1990] else 0.05\n\n        # Add label\n        ax1.text(year, df['value'].iloc[i] + offset, value_text,\n                 ha='center', va='bottom', fontsize=7, color='#363636', fontweight=fontweight)\n\n# Remove spines\nfor ax in [ax1, ax2]:\n    for spine in [\"top\", \"bottom\"]:\n        ax.spines[spine].set_visible(False)\n\n# Add Data Source\nspaces = ' ' * 23\nax1.text(0, -0.16, f'{spaces}NASA Goddard Institute for Space Studies\\nThe Global Carbon Project\\'s fossil CO₂ emissions dataset', \n         transform=ax1.transAxes, \n         fontsize=8, \n         color='gray', \n         ha='left', \n         family='sans-serif')\n\n# Add Data Source bold\nax1.text(0, -0.16, 'Data Source:\\n ', \n         transform=ax1.transAxes, \n         fontsize=8, \n         color='gray', \n         ha='left', \n         family='sans-serif', \n         fontweight='bold')\n\n # Add Year label\nformatted_date = 2024 \nax1.text(1, 1.12, f'{formatted_date}',\n    transform=ax1.transAxes, \n    fontsize=18, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Celsius\nax1.text(-0.04, -0.08, '°C', \n    transform=ax1.transAxes, \n    fontsize=10, \n    fontweight='bold',\n    color='black')\n\n# Add CO2\nax1.text(1.01, -0.08, r'CO$_2$', \n    transform=ax1.transAxes, \n    fontsize=10, \n    fontweight='bold',\n    color='black')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it..\nplt.savefig('C:/Users/guill/Downloads/FIG_NASA_Temperature_Anomalies.png', format='png', bbox_inches='tight')\n\n# Show the plot!\nplt.show()"
  }
]