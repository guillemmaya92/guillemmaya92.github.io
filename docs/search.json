[
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Date\n\n\nTitle\n\n\n\n\n\n\nMar 4, 2025\n\n\nBitcoin Wealth Distribution: Utopian vision of narcocapitalism\n\n\n\n\nFeb 17, 2025\n\n\nExploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity\n\n\n\n\nJan 25, 2025\n\n\nDistribution of Global GDP: Visualizing Income Mountains\n\n\n\n\nDec 27, 2024\n\n\nBitcoin Logarithmic Trends: Analysis since each halving\n\n\n\n\nOct 25, 2024\n\n\nPolar Axis demonstration\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "posts/2025/flags-inequalities-gdp/index.html",
    "href": "posts/2025/flags-inequalities-gdp/index.html",
    "title": "Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity",
    "section": "",
    "text": "A plot that shows the current Inequalities in capital productivity.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport requests\nimport plotly.graph_objects as go\nimport numpy as np\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - IMF (1980-2030)\n# =====================================================================\n#Parametro\nparameters = ['NGDPD', 'PPPGDP', 'LP']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Pivot Parameter to columns and filter nulls\ndf_imf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\n\n# Filter after 2024\ndf_imf = df_imf[df_imf['Year'] == 2024]\n\n# Data Manipulation\n# =====================================================================\n# Concat and filter dataframes\ndf = df_imf.dropna(subset=['NGDPD', 'PPPGDP', 'LP'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year', 'NGDPD', 'PPPGDP', 'LP']]\ndf = df[df['Cod_Currency'].notna()]\n\n# Calculate PPP\ndf = df.groupby(['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year'])[['NGDPD', 'PPPGDP', 'LP']].sum()\ndf = df.reset_index()\ndf['PPP'] = df['NGDPD'] / df['PPPGDP']\ndf['NGDPDPC'] = df['NGDPD'] / df['LP']\ndf['PPPPC'] = df['PPPGDP'] / df['LP']\n\n# Calculate Average Weight and Percent\ndf['AVG_Weight'] = df.groupby('Year')['NGDPDPC'].transform(lambda x: np.average(x, weights=df.loc[x.index, 'LP']))\ndf['Percent'] = df['NGDPD'] / df.groupby('Year')['NGDPD'].transform('sum')\n\n# Filtering\ndf = df[df['NGDPDPC'] &lt; 115 ]\ndf = df[df['PPP'] &lt; 1.25]\ndf = df[~df['ISO2'].isin(['SZ', 'VA', 'NC', 'CI', 'MW', 'SS', 'MY'])]\n\n# Data Visualization\n# =====================================================================\nfig = go.Figure()\n\n# Tamaño de los marcadores\nmarker_size = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 100 + 3\nline_width  = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 4 + 0.5\n\n# Add scatter plot\nfig.add_trace(go.Scatter(\n    x=df[\"PPP\"],\n    y=df[\"NGDPDPC\"],\n    mode='markers',\n    text=df[\"Country\"],\n    marker=dict(\n        size=marker_size,\n        color=\"rgba(0,0,0,0)\",\n        line=dict(\n            width=line_width,\n            color='black'\n        )\n    ),\n    hovertemplate=\"&lt;b&gt;Country:&lt;/b&gt; %{text}&lt;br&gt;\" +\n                  \"&lt;b&gt;GDP per Capita:&lt;/b&gt; $%{y:.2f}&lt;br&gt;\" + \n                  \"&lt;b&gt;PPP:&lt;/b&gt; $%{x:.2f}&lt;extra&gt;&lt;/extra&gt;\",\n    showlegend=False\n))\n\n# Add flag images to scatterplot\nfor i, row in df.iterrows():\n    country_iso = row[\"ISO2\"]\n    \n    # Calculate image size\n    image_size = marker_size[i] * 0.21\n\n    # Add the flag image\n    fig.add_layout_image(\n        dict(\n            source=f\"https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/{country_iso}.png\",\n            xref=\"x\",\n            yref=\"y\",\n            xanchor=\"center\",\n            yanchor=\"middle\",\n            x=row[\"PPP\"],\n            y=row[\"NGDPDPC\"],\n            sizex=image_size,\n            sizey=image_size,\n            sizing=\"contain\",\n            opacity=0.8,\n            layer=\"above\"\n        )\n    )\n    \n# Modeling a line trend\nz = np.polyfit(df['PPP'], df['NGDPDPC'], 2, w=df['NGDPD'])\np = np.poly1d(z)\nx_range = np.linspace(df['PPP'].min(), df['PPP'].max(), 100)\ny_range = p(x_range)\n\n# Add the line trend\nfig.add_trace(go.Scatter(\n    x=x_range,\n    y=y_range,\n    mode='lines',\n    name='Trend Line',\n    line=dict(color='darkred', width=0.5),\n    showlegend=False\n))\n\n# Add red and green shapes\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=0, x1=1,\n    y0=0, y1=1,\n    fillcolor=\"red\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=1, x1=1.2,\n    y0=0, y1=1,\n    fillcolor=\"green\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\n\n# Configuration plot\nfig.update_layout(\n    title=\"&lt;b&gt;Global Inequalities in GDP per Capita&lt;/b&gt;\",\n    title_x=0.11,\n    title_font=dict(size=16),\n    annotations=[\n        dict(\n            text=\"Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.07,\n            showarrow=False,\n            font=dict(size=11)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; IMF World Economic Outlook Database, 2024\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.13,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"2024\",\n            xref=\"paper\", \n            yref=\"paper\",\n            x=1, \n            y=1.1,\n            showarrow=False,\n            font=dict(size=22, color='lightgray', weight='bold'),\n            align=\"right\"\n        )\n    ],\n    xaxis=dict(\n        title=\"&lt;b&gt;GAP Between PPP and Market Exchange Rate&lt;/b&gt;\",\n        range=[0, 1.2],\n        tickvals=[i * 1.2 / 6 for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    yaxis=dict(\n        title=\"&lt;b&gt;GDP per Capita (US$)&lt;/b&gt;\",\n        range=[0, 120],\n        tickvals=[i * 120 / 6 for i in range(7)],\n        ticktext=[f\"{int(i * 120 / 6)}k\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    height=750,\n    width=750,\n    plot_bgcolor=\"white\",\n    paper_bgcolor=\"white\"\n)\n\n# Add a custom legend\nsize_legend = ['Smaller', 'Middle', 'Bigger']\nsize_values = [5, 10, 20]\n\nfor label, size in zip(size_legend, size_values):\n    fig.add_trace(go.Scatter(\n        x=[None],\n        y=[None],\n        mode='markers',\n        marker=dict(\n            size=size,\n            color=\"rgba(0,0,0,0)\",\n            line=dict(\n                width=1,\n                color='black'\n            )\n        ),\n        legendgroup='size',\n        showlegend=True,\n        name=f'{label}'\n    ))\n\nfig.update_layout(\n    legend=dict(\n        title=dict(text='&lt;b&gt;   GDP Scale&lt;/b&gt;'), \n        font=dict(size=11),\n        x=0.025,\n        y=0.95,\n        xanchor='left',\n        bgcolor='white',\n        bordercolor='black',\n        borderwidth=1\n    )\n)\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/2025/flags-inequalities-gdp/index.html#summary",
    "href": "posts/2025/flags-inequalities-gdp/index.html#summary",
    "title": "Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity",
    "section": "",
    "text": "A plot that shows the current Inequalities in capital productivity.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport requests\nimport plotly.graph_objects as go\nimport numpy as np\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'ISO3'})\n\n# Data Extraction - IMF (1980-2030)\n# =====================================================================\n#Parametro\nparameters = ['NGDPD', 'PPPGDP', 'LP']\n\n# Create an empty list\nrecords = []\n\n# Iterar sobre cada parámetro\nfor parameter in parameters:\n    # Request URL\n    url = f\"https://www.imf.org/external/datamapper/api/v1/{parameter}\"\n    response = requests.get(url)\n    data = response.json()\n    values = data.get('values', {})\n\n    # Iterate over each country and year\n    for country, years in values.get(parameter, {}).items():\n        for year, value in years.items():\n            records.append({\n                'Parameter': parameter,\n                'ISO3': country,\n                'Year': int(year),\n                'Value': float(value)\n            })\n    \n# Create dataframe\ndf_imf = pd.DataFrame(records)\n\n# Pivot Parameter to columns and filter nulls\ndf_imf = df_imf.pivot(index=['ISO3', 'Year'], columns='Parameter', values='Value').reset_index()\n\n# Filter after 2024\ndf_imf = df_imf[df_imf['Year'] == 2024]\n\n# Data Manipulation\n# =====================================================================\n# Concat and filter dataframes\ndf = df_imf.dropna(subset=['NGDPD', 'PPPGDP', 'LP'], how='any')\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='ISO3', right_on='ISO3')\ndf = df[['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year', 'NGDPD', 'PPPGDP', 'LP']]\ndf = df[df['Cod_Currency'].notna()]\n\n# Calculate PPP\ndf = df.groupby(['Region', 'ISO2', 'Country', 'Cod_Currency', 'Year'])[['NGDPD', 'PPPGDP', 'LP']].sum()\ndf = df.reset_index()\ndf['PPP'] = df['NGDPD'] / df['PPPGDP']\ndf['NGDPDPC'] = df['NGDPD'] / df['LP']\ndf['PPPPC'] = df['PPPGDP'] / df['LP']\n\n# Calculate Average Weight and Percent\ndf['AVG_Weight'] = df.groupby('Year')['NGDPDPC'].transform(lambda x: np.average(x, weights=df.loc[x.index, 'LP']))\ndf['Percent'] = df['NGDPD'] / df.groupby('Year')['NGDPD'].transform('sum')\n\n# Filtering\ndf = df[df['NGDPDPC'] &lt; 115 ]\ndf = df[df['PPP'] &lt; 1.25]\ndf = df[~df['ISO2'].isin(['SZ', 'VA', 'NC', 'CI', 'MW', 'SS', 'MY'])]\n\n# Data Visualization\n# =====================================================================\nfig = go.Figure()\n\n# Tamaño de los marcadores\nmarker_size = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 100 + 3\nline_width  = np.sqrt(df[\"NGDPD\"] / df[\"NGDPD\"].max()) * 4 + 0.5\n\n# Add scatter plot\nfig.add_trace(go.Scatter(\n    x=df[\"PPP\"],\n    y=df[\"NGDPDPC\"],\n    mode='markers',\n    text=df[\"Country\"],\n    marker=dict(\n        size=marker_size,\n        color=\"rgba(0,0,0,0)\",\n        line=dict(\n            width=line_width,\n            color='black'\n        )\n    ),\n    hovertemplate=\"&lt;b&gt;Country:&lt;/b&gt; %{text}&lt;br&gt;\" +\n                  \"&lt;b&gt;GDP per Capita:&lt;/b&gt; $%{y:.2f}&lt;br&gt;\" + \n                  \"&lt;b&gt;PPP:&lt;/b&gt; $%{x:.2f}&lt;extra&gt;&lt;/extra&gt;\",\n    showlegend=False\n))\n\n# Add flag images to scatterplot\nfor i, row in df.iterrows():\n    country_iso = row[\"ISO2\"]\n    \n    # Calculate image size\n    image_size = marker_size[i] * 0.21\n\n    # Add the flag image\n    fig.add_layout_image(\n        dict(\n            source=f\"https://raw.githubusercontent.com/matahombres/CSS-Country-Flags-Rounded/master/flags/{country_iso}.png\",\n            xref=\"x\",\n            yref=\"y\",\n            xanchor=\"center\",\n            yanchor=\"middle\",\n            x=row[\"PPP\"],\n            y=row[\"NGDPDPC\"],\n            sizex=image_size,\n            sizey=image_size,\n            sizing=\"contain\",\n            opacity=0.8,\n            layer=\"above\"\n        )\n    )\n    \n# Modeling a line trend\nz = np.polyfit(df['PPP'], df['NGDPDPC'], 2, w=df['NGDPD'])\np = np.poly1d(z)\nx_range = np.linspace(df['PPP'].min(), df['PPP'].max(), 100)\ny_range = p(x_range)\n\n# Add the line trend\nfig.add_trace(go.Scatter(\n    x=x_range,\n    y=y_range,\n    mode='lines',\n    name='Trend Line',\n    line=dict(color='darkred', width=0.5),\n    showlegend=False\n))\n\n# Add red and green shapes\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=0, x1=1,\n    y0=0, y1=1,\n    fillcolor=\"red\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\nfig.add_shape(\n    type=\"rect\",\n    xref=\"x\", yref=\"paper\",\n    x0=1, x1=1.2,\n    y0=0, y1=1,\n    fillcolor=\"green\",\n    opacity=0.04,\n    layer=\"below\",\n    line_width=0\n)\n\n# Configuration plot\nfig.update_layout(\n    title=\"&lt;b&gt;Global Inequalities in GDP per Capita&lt;/b&gt;\",\n    title_x=0.11,\n    title_font=dict(size=16),\n    annotations=[\n        dict(\n            text=\"Exploring Discrepancies between Market Exchanges Rates and Purchasing Power Parity\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=1.07,\n            showarrow=False,\n            font=dict(size=11)\n        ),\n        dict(\n            text=\"&lt;b&gt;Data Source:&lt;/b&gt; IMF World Economic Outlook Database, 2024\",\n            xref=\"paper\",\n            yref=\"paper\",\n            x=0,\n            y=-0.13,\n            showarrow=False,\n            font=dict(size=10),\n            align=\"left\"\n        ),\n        dict(\n            text=f\"2024\",\n            xref=\"paper\", \n            yref=\"paper\",\n            x=1, \n            y=1.1,\n            showarrow=False,\n            font=dict(size=22, color='lightgray', weight='bold'),\n            align=\"right\"\n        )\n    ],\n    xaxis=dict(\n        title=\"&lt;b&gt;GAP Between PPP and Market Exchange Rate&lt;/b&gt;\",\n        range=[0, 1.2],\n        tickvals=[i * 1.2 / 6 for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    yaxis=dict(\n        title=\"&lt;b&gt;GDP per Capita (US$)&lt;/b&gt;\",\n        range=[0, 120],\n        tickvals=[i * 120 / 6 for i in range(7)],\n        ticktext=[f\"{int(i * 120 / 6)}k\" for i in range(7)],\n        showline=True,\n        linewidth=1,\n        linecolor=\"black\",\n        gridcolor=\"#ebebeb\"\n    ),\n    height=750,\n    width=750,\n    plot_bgcolor=\"white\",\n    paper_bgcolor=\"white\"\n)\n\n# Add a custom legend\nsize_legend = ['Smaller', 'Middle', 'Bigger']\nsize_values = [5, 10, 20]\n\nfor label, size in zip(size_legend, size_values):\n    fig.add_trace(go.Scatter(\n        x=[None],\n        y=[None],\n        mode='markers',\n        marker=dict(\n            size=size,\n            color=\"rgba(0,0,0,0)\",\n            line=dict(\n                width=1,\n                color='black'\n            )\n        ),\n        legendgroup='size',\n        showlegend=True,\n        name=f'{label}'\n    ))\n\nfig.update_layout(\n    legend=dict(\n        title=dict(text='&lt;b&gt;   GDP Scale&lt;/b&gt;'), \n        font=dict(size=11),\n        x=0.025,\n        y=0.95,\n        xanchor='left',\n        bgcolor='white',\n        bordercolor='black',\n        borderwidth=1\n    )\n)\n\n# Show the plot!\nfig.show()"
  },
  {
    "objectID": "posts/2025/bitcoin-halvings/index.html",
    "href": "posts/2025/bitcoin-halvings/index.html",
    "title": "Bitcoin Logarithmic Trends: Analysis since each halving",
    "section": "",
    "text": "A plot that shows the logarithmic price of Bitcoin over each halving period.\n\n\nCode\n# Libraries\n# ==============================================================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport requests\n\n# Get API Data\n# ==============================================================================\n# Create a df with final year dates\ndp = pd.DataFrame({'date': pd.date_range(start='2010-12-31', end='2024-12-31', freq='Y')})\ndp['to_ts'] = dp['date'].apply(lambda x: int(pd.to_datetime(x).timestamp()))\n\n# Create an empty list\ndataframes = []\n\n# Iterate API with each date\nfor to_ts in dp['to_ts']:\n    # Build an URL with parameters and transform data\n    url = f\"https://min-api.cryptocompare.com/data/v2/histoday?fsym=BTC&tsym=USD&limit=365&toTs={to_ts}\"\n    response = requests.get(url)\n    data = response.json().get(\"Data\", {}).get(\"Data\", [])\n    df = pd.DataFrame([\n        {\n            \"symbol\": \"BTCUSD\",\n            \"date\": pd.to_datetime(entry[\"time\"], unit=\"s\").date(),\n            \"open\": entry[\"open\"],\n            \"close\": entry[\"close\"],\n            \"low\": entry[\"low\"],\n            \"high\": entry[\"high\"],\n            \"volume\": entry[\"volumeto\"]\n        }\n        for entry in data\n    ])\n    dataframes.append(df)\n# Combine all df into one\nbtc = pd.concat(dataframes, ignore_index=True)\n\n# DataSet 0 - Halving\n#================================================================================\nhalving = {'halving': [0 , 1, 2, 3, 4],\n           'date': ['2009-01-03', '2012-11-28', '2016-07-09', '2020-05-11', '2024-04-20'] \n           }\n\nhalving = pd.DataFrame(halving)\nhalving['date'] = pd.to_datetime(halving['date'])\n\n# DataSet 1 - BTC Price\n# ==============================================================================\n# Prepare dataset\nbtc = btc.drop_duplicates()\nbtc['date'] = pd.to_datetime(btc['date'])\nbtc['year_month'] = btc['date'].dt.strftime('%Y-%m')\nbtc = btc.set_index('date')\nbtc = btc.asfreq('D').ffill()\nbtc = btc.reset_index()\nbtc.sort_values(by=['date'], inplace=True)\nbtc = pd.merge(btc, halving, on='date', how='left')\nbtc['halving'].fillna(method='ffill', inplace=True)\nbtc['halving'].fillna(0, inplace=True)\nbtc['halving'] = btc['halving'].astype(int)\nbtc['first_close'] = btc.groupby('halving')['close'].transform('first')\nbtc['increase'] = (btc['close'] - btc['first_close']) / btc['first_close'] * 100\nbtc['days'] = btc.groupby('halving').cumcount() + 1\nbtc['closelog'] = np.log10(btc['close'])\nbtc = btc[btc['halving'] &gt;= 1]\nbtc['daystotal'] = btc.groupby('symbol').cumcount() + 1\n\n# Graph 1 - SEABORN\n# ==============================================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Colors Background\nregions = [\n    (0, 500, '#6B8E23'), # Green\n    (500, 1000, '#FF4500'), # Red\n    (1000, 1500, '#FFA500') # Orange\n    ]  \n\n# Colors Palette Lines\nlines = {\n    0: '#E0E0E0',  # Very Light Grey\n    1: '#C0C0C0',  # Light Grey\n    2: '#808080',  # Medium Grey\n    3: '#404040',  # Dark Grey\n    4: '#8B0000'   # Red\n}\n\n# Seaborn to plot a graph\nsns.set(style=\"whitegrid\", rc={\"grid.color\": \"0.95\", \"axes.grid.axis\": \"y\"})\nplt.figure(figsize=(16, 9))\nsns.lineplot(x='days', y='closelog', hue='halving', data=btc, markers=True, palette=lines, linewidth=1)\n\n# Add region colors in the background\nfor start, end, color in regions:\n    plt.axvspan(start, end, color=color, alpha=0.05)\n\n# Title and axis\nplt.title('Bitcoin Logarithmic Trends: Analysis Since Each Halving', fontsize=16, fontweight='bold', pad=20)\nplt.xlabel('Days',  fontsize=10, fontweight='bold')\nplt.ylabel('Log Price', fontsize=10, fontweight='bold')\nplt.xlim(0, 1500)\nplt.xticks(range(0, 1501, 125), fontsize=9)\nplt.tick_params(axis='both', labelsize=8)\nplt.yticks(fontsize=9)\n\n# Custom legend\nlegend = plt.legend(title=\"Halving\", loc='lower right', fontsize=8, title_fontsize='10')\nnew_title = 'Dates:'\nlegend.set_title(new_title)\nnew_labels = ['1st Halving: 2012-11-28 to 2016-07-09', '2nd Halving: 2016-07-09 to 2020-05-11', '3rd Halving: 2020-05-11 to 2024-04-20', '4th Halving: 2024-04-20 to present'] # Adjust the number of labels according to your data\nfor text, new_label in zip(legend.texts, new_labels):\n    text.set_text(new_label)\n\n# Maximo First 750 days\nbtc1 = btc[(btc['days'] &gt;= 0) & (btc['days'] &lt;= 750)]\nfor halving, group in btc1.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='*', color='darkgoldenrod', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgoldenrod')\n\n# Min Between 500 and 1000 days\nbtc2 = btc[(btc['days'] &gt;= 500) & (btc['days'] &lt;= 1000)]\nfor halving, group in btc2.groupby('halving'):\n    min_value = group['closelog'].min()\n    min_row = group[group['closelog'] == min_value].iloc[0]\n    plt.plot(min_row['days'], min_row['closelog'] - 0.05, marker='v', color='darkred', markersize=5)\n    plt.text(min_row['days'], min_row['closelog'] -0.15, f'{min_row[\"close\"]:,.0f} ({min_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkred')\n\n# Max After 750 days \nbtc3 = btc[(btc['days'] &gt;= 750) & (btc['days'] &lt;= 1500)]\nfor halving, group in btc3.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='^', color='darkgreen', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgreen')\n\n# Custom Last Dots\nmax_vals = btc.groupby('halving').agg({'closelog': 'last', 'days': 'max'}).reset_index()\nfor index, row in max_vals.iterrows():\n    plt.plot(row['days'], row['closelog'], 'ro', markersize=2)\n\n# Custom Line labels\nfor halving, group in btc.groupby('halving'):\n    last_point = group.iloc[-1]\n    x = last_point['days']\n    y = last_point['closelog']\n    max_days = group['days'].max()\n    plt.text(x + 8, y, f'Halving {halving}\\n{max_days} days', color=lines[halving], fontsize=8, ha='left', va='center')\n    \n# Add Year Label\ncurrent_year_month = btc['year_month'].max() \nplt.text(1, 1.05, f'{current_year_month}',\n    transform=plt.gca().transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nplt.text(0, -0.065, 'Data Source: CryptoCompare', \n         transform=plt.gca().transAxes, \n         fontsize=8, \n         color='gray')\n\n# Adjust layout\nplt.tight_layout()\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/2025/bitcoin-halvings/index.html#summary",
    "href": "posts/2025/bitcoin-halvings/index.html#summary",
    "title": "Bitcoin Logarithmic Trends: Analysis since each halving",
    "section": "",
    "text": "A plot that shows the logarithmic price of Bitcoin over each halving period.\n\n\nCode\n# Libraries\n# ==============================================================================\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport requests\n\n# Get API Data\n# ==============================================================================\n# Create a df with final year dates\ndp = pd.DataFrame({'date': pd.date_range(start='2010-12-31', end='2024-12-31', freq='Y')})\ndp['to_ts'] = dp['date'].apply(lambda x: int(pd.to_datetime(x).timestamp()))\n\n# Create an empty list\ndataframes = []\n\n# Iterate API with each date\nfor to_ts in dp['to_ts']:\n    # Build an URL with parameters and transform data\n    url = f\"https://min-api.cryptocompare.com/data/v2/histoday?fsym=BTC&tsym=USD&limit=365&toTs={to_ts}\"\n    response = requests.get(url)\n    data = response.json().get(\"Data\", {}).get(\"Data\", [])\n    df = pd.DataFrame([\n        {\n            \"symbol\": \"BTCUSD\",\n            \"date\": pd.to_datetime(entry[\"time\"], unit=\"s\").date(),\n            \"open\": entry[\"open\"],\n            \"close\": entry[\"close\"],\n            \"low\": entry[\"low\"],\n            \"high\": entry[\"high\"],\n            \"volume\": entry[\"volumeto\"]\n        }\n        for entry in data\n    ])\n    dataframes.append(df)\n# Combine all df into one\nbtc = pd.concat(dataframes, ignore_index=True)\n\n# DataSet 0 - Halving\n#================================================================================\nhalving = {'halving': [0 , 1, 2, 3, 4],\n           'date': ['2009-01-03', '2012-11-28', '2016-07-09', '2020-05-11', '2024-04-20'] \n           }\n\nhalving = pd.DataFrame(halving)\nhalving['date'] = pd.to_datetime(halving['date'])\n\n# DataSet 1 - BTC Price\n# ==============================================================================\n# Prepare dataset\nbtc = btc.drop_duplicates()\nbtc['date'] = pd.to_datetime(btc['date'])\nbtc['year_month'] = btc['date'].dt.strftime('%Y-%m')\nbtc = btc.set_index('date')\nbtc = btc.asfreq('D').ffill()\nbtc = btc.reset_index()\nbtc.sort_values(by=['date'], inplace=True)\nbtc = pd.merge(btc, halving, on='date', how='left')\nbtc['halving'].fillna(method='ffill', inplace=True)\nbtc['halving'].fillna(0, inplace=True)\nbtc['halving'] = btc['halving'].astype(int)\nbtc['first_close'] = btc.groupby('halving')['close'].transform('first')\nbtc['increase'] = (btc['close'] - btc['first_close']) / btc['first_close'] * 100\nbtc['days'] = btc.groupby('halving').cumcount() + 1\nbtc['closelog'] = np.log10(btc['close'])\nbtc = btc[btc['halving'] &gt;= 1]\nbtc['daystotal'] = btc.groupby('symbol').cumcount() + 1\n\n# Graph 1 - SEABORN\n# ==============================================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Colors Background\nregions = [\n    (0, 500, '#6B8E23'), # Green\n    (500, 1000, '#FF4500'), # Red\n    (1000, 1500, '#FFA500') # Orange\n    ]  \n\n# Colors Palette Lines\nlines = {\n    0: '#E0E0E0',  # Very Light Grey\n    1: '#C0C0C0',  # Light Grey\n    2: '#808080',  # Medium Grey\n    3: '#404040',  # Dark Grey\n    4: '#8B0000'   # Red\n}\n\n# Seaborn to plot a graph\nsns.set(style=\"whitegrid\", rc={\"grid.color\": \"0.95\", \"axes.grid.axis\": \"y\"})\nplt.figure(figsize=(16, 9))\nsns.lineplot(x='days', y='closelog', hue='halving', data=btc, markers=True, palette=lines, linewidth=1)\n\n# Add region colors in the background\nfor start, end, color in regions:\n    plt.axvspan(start, end, color=color, alpha=0.05)\n\n# Title and axis\nplt.title('Bitcoin Logarithmic Trends: Analysis Since Each Halving', fontsize=16, fontweight='bold', pad=20)\nplt.xlabel('Days',  fontsize=10, fontweight='bold')\nplt.ylabel('Log Price', fontsize=10, fontweight='bold')\nplt.xlim(0, 1500)\nplt.xticks(range(0, 1501, 125), fontsize=9)\nplt.tick_params(axis='both', labelsize=8)\nplt.yticks(fontsize=9)\n\n# Custom legend\nlegend = plt.legend(title=\"Halving\", loc='lower right', fontsize=8, title_fontsize='10')\nnew_title = 'Dates:'\nlegend.set_title(new_title)\nnew_labels = ['1st Halving: 2012-11-28 to 2016-07-09', '2nd Halving: 2016-07-09 to 2020-05-11', '3rd Halving: 2020-05-11 to 2024-04-20', '4th Halving: 2024-04-20 to present'] # Adjust the number of labels according to your data\nfor text, new_label in zip(legend.texts, new_labels):\n    text.set_text(new_label)\n\n# Maximo First 750 days\nbtc1 = btc[(btc['days'] &gt;= 0) & (btc['days'] &lt;= 750)]\nfor halving, group in btc1.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='*', color='darkgoldenrod', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgoldenrod')\n\n# Min Between 500 and 1000 days\nbtc2 = btc[(btc['days'] &gt;= 500) & (btc['days'] &lt;= 1000)]\nfor halving, group in btc2.groupby('halving'):\n    min_value = group['closelog'].min()\n    min_row = group[group['closelog'] == min_value].iloc[0]\n    plt.plot(min_row['days'], min_row['closelog'] - 0.05, marker='v', color='darkred', markersize=5)\n    plt.text(min_row['days'], min_row['closelog'] -0.15, f'{min_row[\"close\"]:,.0f} ({min_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkred')\n\n# Max After 750 days \nbtc3 = btc[(btc['days'] &gt;= 750) & (btc['days'] &lt;= 1500)]\nfor halving, group in btc3.groupby('halving'):\n    max_value = group['closelog'].max()\n    max_row = group[group['closelog'] == max_value].iloc[0]\n    plt.plot(max_row['days'], max_row['closelog'] +0.05, marker='^', color='darkgreen', markersize=5)\n    plt.text(max_row['days'], max_row['closelog'] +0.1, f'{max_row[\"close\"]:,.0f} ({max_row[\"increase\"]:,.0f})%', fontsize=7, ha='center', color='darkgreen')\n\n# Custom Last Dots\nmax_vals = btc.groupby('halving').agg({'closelog': 'last', 'days': 'max'}).reset_index()\nfor index, row in max_vals.iterrows():\n    plt.plot(row['days'], row['closelog'], 'ro', markersize=2)\n\n# Custom Line labels\nfor halving, group in btc.groupby('halving'):\n    last_point = group.iloc[-1]\n    x = last_point['days']\n    y = last_point['closelog']\n    max_days = group['days'].max()\n    plt.text(x + 8, y, f'Halving {halving}\\n{max_days} days', color=lines[halving], fontsize=8, ha='left', va='center')\n    \n# Add Year Label\ncurrent_year_month = btc['year_month'].max() \nplt.text(1, 1.05, f'{current_year_month}',\n    transform=plt.gca().transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nplt.text(0, -0.065, 'Data Source: CryptoCompare', \n         transform=plt.gca().transAxes, \n         fontsize=8, \n         color='gray')\n\n# Adjust layout\nplt.tight_layout()\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Guillem Maya",
    "section": "",
    "text": "From nowhere, delving into the challenges faced by modern economies. I am an enthusiast of data and economics, interested in exploring and uncovering a genuine comprehension of the global world. Focused on social inequalities and the development of a sustainable economy, I pursue a transversal approach that examines these concepts from a holistic and multidisciplinary perspective.\n\n\n Back to top"
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "Guillem Maya",
    "section": "",
    "text": "Download pdf"
  },
  {
    "objectID": "cv.html#experience",
    "href": "cv.html#experience",
    "title": "Guillem Maya",
    "section": "Experience",
    "text": "Experience"
  },
  {
    "objectID": "cv.html#education",
    "href": "cv.html#education",
    "title": "Guillem Maya",
    "section": "Education",
    "text": "Education"
  },
  {
    "objectID": "cv.html#language",
    "href": "cv.html#language",
    "title": "Guillem Maya",
    "section": "Language",
    "text": "Language"
  },
  {
    "objectID": "cv.html#skills",
    "href": "cv.html#skills",
    "title": "Guillem Maya",
    "section": "Skills",
    "text": "Skills"
  },
  {
    "objectID": "posts/2025/bitcoin-distribution/index.html",
    "href": "posts/2025/bitcoin-distribution/index.html",
    "title": "Bitcoin Wealth Distribution: Utopian vision of narcocapitalism",
    "section": "",
    "text": "A plot that shows the distribution wealth of Bitcoin among the wallets with a balance greater than $5,000 USD.\n\n\nCode\n# Libraries\n# ===================================================\nimport pandas as pd\nimport numpy as np\nfrom bs4 import BeautifulSoup\nimport requests\nfrom io import StringIO\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport matplotlib.patches as patches\n\n# Bitcoin Price\n# ===================================================\nurl = \"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\"\nresponse = requests.get(url)\ndata = response.json()\nbtcprice = data.get(\"USD\")\n\n# Bitcoin Supply\n# ===================================================\ndef get_btc_supply():\n    response = requests.get(\"https://blockchain.info/q/totalbc\")\n    satoshi = int(response.text)\n    btcsupply = satoshi / 100000000\n    return btcsupply\nbtcsupply = get_btc_supply()\n\n# Data Extraction\n# ===================================================\nurl = \"https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html\"\nsoup = BeautifulSoup(requests.get(url).text, \"html.parser\")\ntable = soup.find(\"table\", {\"class\": \"table table-condensed bb\"})\ndf = pd.read_html(StringIO(str(table)))[0]\n\n# Data Transformation\n# ===================================================\n# Select columns\ndf = df[['Balance, BTC', 'Addresses', 'BTC']]\n\n# Rename columns and add average\ndf.rename(columns={'Addresses': 'rows', 'BTC': 'btc'}, inplace=True)\n\n# Extract start and end range\ndf['start'] = df['Balance, BTC'].str.extract(r'[\\[\\(](\\d[\\d,\\.]*)')\ndf['end'] = df['Balance, BTC'].str.extract(r'-\\s([\\d,\\.]+)\\)')\ndf['btc'] = df['btc'].str.extract('([0-9.]+)')\n\n# Convert to values\ndf['rows'] = df['rows'].replace({',': ''}, regex=True).astype(int)\ndf['start'] = df['start'].replace({',': ''}, regex=True).astype(float)\ndf['end'] = df['end'].replace({',': ''}, regex=True).astype(float)\ndf['btc'] = df['btc'].replace({',': ''}, regex=True).astype(float)\n\n# Add average price\ndf['average'] = df['btc'] / df['rows']\n\n# Select columns\ndf = df[['rows', 'start', 'end', 'btc', 'average']]\n\n# Change first and last value\ndf.loc[df.index[0], 'start'] = 0.000001\ndf.loc[df.index[-1], 'end'] = 250000\n\n# Create a list\nresult = []\n\n# Iterate over each row \nfor index, row in df.iterrows():\n    n = int(row['rows'])\n    start = row['start']\n    end = row['end']\n    average = row['average']\n    \n    # Generate a distribution\n    valores = np.logspace(np.log(start) / np.log(12), np.log(end) / np.log(12), n)\n        \n   # Calcular el factor de escala para ajustar el promedio\n    current_average = np.mean(valores)\n    scale_factor = average / current_average\n    adjusted_values = valores * scale_factor\n\n    # Add values to result list\n    result.extend(valores)\n\n# Crear a dataframe with all values\ndf = pd.DataFrame(result, columns=['btc'])\n\n# Calculate marketcap\nmarketcap = btcsupply * btcprice\n\n# USD Value, Filter &gt;5000 and count\ndf['usd'] = df['btc'] * btcprice\ndf = df[df['usd'] &gt; 5000]\ndf['count'] = 1\n\n# Grouping by 100 percentiles\ndf['percentile'] = pd.qcut(df['btc'], 100, labels=False) + 1\n\n# Grouping by 10 percentiles\ndf['percentile2'] = pd.cut(\n    df['percentile'], \n    bins=range(1, 111, 10), \n    right=False, \n    labels=[i + 9 for i in range(1, 101, 10)]\n).astype(int)\n\n# Calculate GINI Index\ndef gini(x):\n    x = np.array(x)\n    x = np.sort(x)\n    n = len(x)\n    gini_index = (2 * np.sum(np.arange(1, n + 1) * x) - (n + 1) * np.sum(x)) / (n * np.sum(x))\n    return gini_index\ngini_value = gini(df['usd'])\n\n# Summarizing data \ndf = df.groupby(['percentile', 'percentile2'])[['usd', 'btc', 'count']].sum().reset_index()\n\n# Average price\ndf['average_usd'] = df['usd'] / df['count']\ndf['percentage'] = df['usd'] / df['usd'].sum()\n\n# Select columns\ndf = df[['percentile', 'percentile2', 'usd', 'count', 'average_usd', 'percentage']]\n\n# Define palette\ncolor_palette = {\n    10: \"#050407\",\n    20: \"#07111e\",\n    30: \"#15334b\",\n    40: \"#2b5778\",\n    50: \"#417da1\",\n    60: \"#5593bb\",\n    70: \"#5a7aa3\",\n    80: \"#6d5e86\",\n    90: \"#a2425c\",\n    100: \"#D21E00\"\n}\n\n# Map palette color\ndf['color'] = df['percentile2'].map(color_palette)\n\n# Percentiles dataframe 2\ndf2 = df.copy()\ndf2 = df2.groupby(['percentile2', 'color'], as_index=False)[['usd', 'count']].sum()\ndf2['average_usd'] = df2['usd'] / df2['count']\ndf2['percentage'] = df2['usd'] / (df2['usd']).sum()\ndf2['count'] = 10\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create the figure and suplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [10, 0.5]})\n\n# First Plot\n# ==================\n# Plot Bars\nbars = ax1.bar(df['percentile'], df['average_usd'], color=df['color'], edgecolor='darkgrey', linewidth=0.5, zorder=2)\n\n# Title and labels\nax1.text(0, 1.1, 'Bitcoin Wealth Distribution', fontsize=13, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.06, 'Intrapercentile Analysis of Wealth Concentration (excluding &lt; 5000$ wallets)', fontsize=9, color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlabel('% Wallets', fontsize=10, weight='bold')\nax1.set_ylabel('Wealth ($)', fontsize=10, weight='bold')\n\n# Configuration\nax1.grid(axis='x', linestyle='-', alpha=0.5, zorder=1)\nax1.set_xlim(0, 101)\nax1.set_ylim(0, 2000000)\nax1.set_xticks(np.arange(0, 101, step=10))\nax1.set_yticks(np.arange(0, 2000001, step=250000))\nax1.tick_params(axis='x', labelsize=10)\nax1.tick_params(axis='y', labelsize=10)\nax1.spines['top'].set_visible(False)\nax1.spines['right'].set_visible(False)\n\n# Function to format Y axis\ndef format_func(value, tick_number):\n    if value &gt;= 1e6:\n        return '{:,.1f}M'.format(value / 1e6)\n    else:\n        return '{:,.0f}K'.format(value / 1e3)\n\n# Formatting x and y axis\nax1.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{x:.0f}%'))\nax1.yaxis.set_major_formatter(FuncFormatter(format_func))\n\n# Lines and area to separate outliers\nax1.axhline(y=1850000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.axhline(y=1800000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.add_patch(patches.Rectangle((0, 1800000), 105, 50000, linewidth=0, edgecolor='none', facecolor='white', zorder=3))\n\n# Y Axis modify the outlier value\nlabels = [item.get_text() for item in ax1.get_yticklabels()]\nlabels[-1] = '17M'\nax1.set_yticklabels(labels)\n\n# Show labels each 10 percentile\nfor i, (bar, value) in enumerate(zip(bars, df['average_usd'])):\n    value_rounded = round(value / 5000) * 5000\n    if i % 10 == 0:\n        ax1.text(bar.get_x() + bar.get_width() / 2, \n                 abs(bar.get_height()) * 1.4 + 50000,\n                 f'{value_rounded:,.0f}',\n                 ha='center', \n                 va='bottom', \n                 fontsize=8.5,\n                 color='#2c2c2c', \n                 rotation=90)\n\n# Show GINI Index\nax1.text(\n    0.09, 0.97, f\"Gini Index: {gini_value:.2f}\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='right',\n    va='top', \n    bbox=dict(boxstyle=\"round,pad=0.3\", edgecolor='gray', facecolor='white')\n)\n\n# Show MarketCap\nax1.text(\n    0.05, 0.88, \n    f\"Price: ${btcprice / 1e3:.0f} k\\nMCap: ${marketcap / 1e12:.2f} Bn\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='center',\n    va='top'\n)\n\n# Second Plot\n# ==================\n# Plot Bars\nax2.barh([0] * len(df2), df2['count'], left=df2['percentile2'] - df2['count'], color=df2['color'])\n\n# Configuration\nax2.grid(axis='x', linestyle='-', color='white', alpha=1, linewidth=0.5)\nax2.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False)\nax2.tick_params(axis='y', which='both', left=False, right=False, labelleft=False)\nax2.spines['top'].set_visible(False)\nax2.spines['right'].set_visible(False)\nax2.spines['left'].set_visible(False)\nax2.spines['bottom'].set_visible(False)\nx_ticks = np.linspace(df2['percentile2'].min(), df2['percentile2'].max(), 10)\nax2.set_xticks(x_ticks)\nax2.set_xlim(0, 101)\n\n# Add label values\nfor i, row in df2.iterrows():\n    plt.text(row['percentile2'] - row['count'] + row['count'] / 2, 0, \n             f'{row[\"percentage\"] * 100:.2f}%', ha='center', va='center', color='white', fontweight='bold')\n    \n # Add Year label\nformatted_date = 2024 \nax1.text(1, 1.1, f'{formatted_date}',\n    transform=ax1.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nax2.text(0, -0.5, 'Data Source: BitInfoCharts. \"Top 100 Richest Bitcoin Addresses.\"',\n         transform=ax2.transAxes,\n         fontsize=8,\n         color='#2c2c2c')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\nplt.savefig(\"C:/Users/guill/Downloads/FIG_BITINFO_Bitcoin_Wealth_Distribution.png\", dpi=300, bbox_inches='tight') \n\n# Plot it!\nplt.show()"
  },
  {
    "objectID": "posts/2025/bitcoin-distribution/index.html#summary",
    "href": "posts/2025/bitcoin-distribution/index.html#summary",
    "title": "Bitcoin Wealth Distribution: Utopian vision of narcocapitalism",
    "section": "",
    "text": "A plot that shows the distribution wealth of Bitcoin among the wallets with a balance greater than $5,000 USD.\n\n\nCode\n# Libraries\n# ===================================================\nimport pandas as pd\nimport numpy as np\nfrom bs4 import BeautifulSoup\nimport requests\nfrom io import StringIO\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import FuncFormatter\nimport matplotlib.patches as patches\n\n# Bitcoin Price\n# ===================================================\nurl = \"https://min-api.cryptocompare.com/data/price?fsym=BTC&tsyms=USD\"\nresponse = requests.get(url)\ndata = response.json()\nbtcprice = data.get(\"USD\")\n\n# Bitcoin Supply\n# ===================================================\ndef get_btc_supply():\n    response = requests.get(\"https://blockchain.info/q/totalbc\")\n    satoshi = int(response.text)\n    btcsupply = satoshi / 100000000\n    return btcsupply\nbtcsupply = get_btc_supply()\n\n# Data Extraction\n# ===================================================\nurl = \"https://bitinfocharts.com/top-100-richest-bitcoin-addresses.html\"\nsoup = BeautifulSoup(requests.get(url).text, \"html.parser\")\ntable = soup.find(\"table\", {\"class\": \"table table-condensed bb\"})\ndf = pd.read_html(StringIO(str(table)))[0]\n\n# Data Transformation\n# ===================================================\n# Select columns\ndf = df[['Balance, BTC', 'Addresses', 'BTC']]\n\n# Rename columns and add average\ndf.rename(columns={'Addresses': 'rows', 'BTC': 'btc'}, inplace=True)\n\n# Extract start and end range\ndf['start'] = df['Balance, BTC'].str.extract(r'[\\[\\(](\\d[\\d,\\.]*)')\ndf['end'] = df['Balance, BTC'].str.extract(r'-\\s([\\d,\\.]+)\\)')\ndf['btc'] = df['btc'].str.extract('([0-9.]+)')\n\n# Convert to values\ndf['rows'] = df['rows'].replace({',': ''}, regex=True).astype(int)\ndf['start'] = df['start'].replace({',': ''}, regex=True).astype(float)\ndf['end'] = df['end'].replace({',': ''}, regex=True).astype(float)\ndf['btc'] = df['btc'].replace({',': ''}, regex=True).astype(float)\n\n# Add average price\ndf['average'] = df['btc'] / df['rows']\n\n# Select columns\ndf = df[['rows', 'start', 'end', 'btc', 'average']]\n\n# Change first and last value\ndf.loc[df.index[0], 'start'] = 0.000001\ndf.loc[df.index[-1], 'end'] = 250000\n\n# Create a list\nresult = []\n\n# Iterate over each row \nfor index, row in df.iterrows():\n    n = int(row['rows'])\n    start = row['start']\n    end = row['end']\n    average = row['average']\n    \n    # Generate a distribution\n    valores = np.logspace(np.log(start) / np.log(12), np.log(end) / np.log(12), n)\n        \n   # Calcular el factor de escala para ajustar el promedio\n    current_average = np.mean(valores)\n    scale_factor = average / current_average\n    adjusted_values = valores * scale_factor\n\n    # Add values to result list\n    result.extend(valores)\n\n# Crear a dataframe with all values\ndf = pd.DataFrame(result, columns=['btc'])\n\n# Calculate marketcap\nmarketcap = btcsupply * btcprice\n\n# USD Value, Filter &gt;5000 and count\ndf['usd'] = df['btc'] * btcprice\ndf = df[df['usd'] &gt; 5000]\ndf['count'] = 1\n\n# Grouping by 100 percentiles\ndf['percentile'] = pd.qcut(df['btc'], 100, labels=False) + 1\n\n# Grouping by 10 percentiles\ndf['percentile2'] = pd.cut(\n    df['percentile'], \n    bins=range(1, 111, 10), \n    right=False, \n    labels=[i + 9 for i in range(1, 101, 10)]\n).astype(int)\n\n# Calculate GINI Index\ndef gini(x):\n    x = np.array(x)\n    x = np.sort(x)\n    n = len(x)\n    gini_index = (2 * np.sum(np.arange(1, n + 1) * x) - (n + 1) * np.sum(x)) / (n * np.sum(x))\n    return gini_index\ngini_value = gini(df['usd'])\n\n# Summarizing data \ndf = df.groupby(['percentile', 'percentile2'])[['usd', 'btc', 'count']].sum().reset_index()\n\n# Average price\ndf['average_usd'] = df['usd'] / df['count']\ndf['percentage'] = df['usd'] / df['usd'].sum()\n\n# Select columns\ndf = df[['percentile', 'percentile2', 'usd', 'count', 'average_usd', 'percentage']]\n\n# Define palette\ncolor_palette = {\n    10: \"#050407\",\n    20: \"#07111e\",\n    30: \"#15334b\",\n    40: \"#2b5778\",\n    50: \"#417da1\",\n    60: \"#5593bb\",\n    70: \"#5a7aa3\",\n    80: \"#6d5e86\",\n    90: \"#a2425c\",\n    100: \"#D21E00\"\n}\n\n# Map palette color\ndf['color'] = df['percentile2'].map(color_palette)\n\n# Percentiles dataframe 2\ndf2 = df.copy()\ndf2 = df2.groupby(['percentile2', 'color'], as_index=False)[['usd', 'count']].sum()\ndf2['average_usd'] = df2['usd'] / df2['count']\ndf2['percentage'] = df2['usd'] / (df2['usd']).sum()\ndf2['count'] = 10\n\nprint(df)\n\n# Data Visualization\n# ===================================================\n# Font Style\nplt.rcParams.update({'font.family': 'sans-serif', 'font.sans-serif': ['Open Sans'], 'font.size': 10})\n\n# Create the figure and suplots\nfig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={'height_ratios': [10, 0.5]})\n\n# First Plot\n# ==================\n# Plot Bars\nbars = ax1.bar(df['percentile'], df['average_usd'], color=df['color'], edgecolor='darkgrey', linewidth=0.5, zorder=2)\n\n# Title and labels\nax1.text(0, 1.1, 'Bitcoin Wealth Distribution', fontsize=13, fontweight='bold', ha='left', transform=ax1.transAxes)\nax1.text(0, 1.06, 'Intrapercentile Analysis of Wealth Concentration (excluding &lt; 5000$ wallets)', fontsize=9, color='#262626', ha='left', transform=ax1.transAxes)\nax1.set_xlabel('% Wallets', fontsize=10, weight='bold')\nax1.set_ylabel('Wealth ($)', fontsize=10, weight='bold')\n\n# Configuration\nax1.grid(axis='x', linestyle='-', alpha=0.5, zorder=1)\nax1.set_xlim(0, 101)\nax1.set_ylim(0, 2000000)\nax1.set_xticks(np.arange(0, 101, step=10))\nax1.set_yticks(np.arange(0, 2000001, step=250000))\nax1.tick_params(axis='x', labelsize=10)\nax1.tick_params(axis='y', labelsize=10)\nax1.spines['top'].set_visible(False)\nax1.spines['right'].set_visible(False)\n\n# Function to format Y axis\ndef format_func(value, tick_number):\n    if value &gt;= 1e6:\n        return '{:,.1f}M'.format(value / 1e6)\n    else:\n        return '{:,.0f}K'.format(value / 1e3)\n\n# Formatting x and y axis\nax1.xaxis.set_major_formatter(FuncFormatter(lambda x, _: f'{x:.0f}%'))\nax1.yaxis.set_major_formatter(FuncFormatter(format_func))\n\n# Lines and area to separate outliers\nax1.axhline(y=1850000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.axhline(y=1800000, color='black', linestyle='--', linewidth=0.5, zorder=4)\nax1.add_patch(patches.Rectangle((0, 1800000), 105, 50000, linewidth=0, edgecolor='none', facecolor='white', zorder=3))\n\n# Y Axis modify the outlier value\nlabels = [item.get_text() for item in ax1.get_yticklabels()]\nlabels[-1] = '17M'\nax1.set_yticklabels(labels)\n\n# Show labels each 10 percentile\nfor i, (bar, value) in enumerate(zip(bars, df['average_usd'])):\n    value_rounded = round(value / 5000) * 5000\n    if i % 10 == 0:\n        ax1.text(bar.get_x() + bar.get_width() / 2, \n                 abs(bar.get_height()) * 1.4 + 50000,\n                 f'{value_rounded:,.0f}',\n                 ha='center', \n                 va='bottom', \n                 fontsize=8.5,\n                 color='#2c2c2c', \n                 rotation=90)\n\n# Show GINI Index\nax1.text(\n    0.09, 0.97, f\"Gini Index: {gini_value:.2f}\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='right',\n    va='top', \n    bbox=dict(boxstyle=\"round,pad=0.3\", edgecolor='gray', facecolor='white')\n)\n\n# Show MarketCap\nax1.text(\n    0.05, 0.88, \n    f\"Price: ${btcprice / 1e3:.0f} k\\nMCap: ${marketcap / 1e12:.2f} Bn\", \n    transform=ax1.transAxes,\n    fontsize=8.5,\n    color='black',\n    ha='center',\n    va='top'\n)\n\n# Second Plot\n# ==================\n# Plot Bars\nax2.barh([0] * len(df2), df2['count'], left=df2['percentile2'] - df2['count'], color=df2['color'])\n\n# Configuration\nax2.grid(axis='x', linestyle='-', color='white', alpha=1, linewidth=0.5)\nax2.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=False)\nax2.tick_params(axis='y', which='both', left=False, right=False, labelleft=False)\nax2.spines['top'].set_visible(False)\nax2.spines['right'].set_visible(False)\nax2.spines['left'].set_visible(False)\nax2.spines['bottom'].set_visible(False)\nx_ticks = np.linspace(df2['percentile2'].min(), df2['percentile2'].max(), 10)\nax2.set_xticks(x_ticks)\nax2.set_xlim(0, 101)\n\n# Add label values\nfor i, row in df2.iterrows():\n    plt.text(row['percentile2'] - row['count'] + row['count'] / 2, 0, \n             f'{row[\"percentage\"] * 100:.2f}%', ha='center', va='center', color='white', fontweight='bold')\n    \n # Add Year label\nformatted_date = 2024 \nax1.text(1, 1.1, f'{formatted_date}',\n    transform=ax1.transAxes,\n    fontsize=22, ha='right', va='top',\n    fontweight='bold', color='#D3D3D3')\n\n# Add Data Source\nax2.text(0, -0.5, 'Data Source: BitInfoCharts. \"Top 100 Richest Bitcoin Addresses.\"',\n         transform=ax2.transAxes,\n         fontsize=8,\n         color='#2c2c2c')\n\n# Adjust layout\nplt.tight_layout()\n\n# Save it...\nplt.savefig(\"C:/Users/guill/Downloads/FIG_BITINFO_Bitcoin_Wealth_Distribution.png\", dpi=300, bbox_inches='tight') \n\n# Plot it!\nplt.show()"
  },
  {
    "objectID": "posts/2025/distribution-mountains-gdpc/index.html",
    "href": "posts/2025/distribution-mountains-gdpc/index.html",
    "title": "Distribution of Global GDP: Visualizing Income Mountains",
    "section": "",
    "text": "A plot that shows the evolution of Daily Income based on GDP per Capita ($US constant 2017) from 1900 to 2100.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.ticker as ticker\nfrom matplotlib.lines import Line2D\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'iso3'})\n\n# Data Extraction (GAPMINDER)\n# ====================================================================\n# URL Github\nurlgap = 'https://raw.githubusercontent.com/guillemmaya92/world_map/refs/heads/main/gapminder-gdp.csv'\ndfgap = pd.read_csv(urlgap, delimiter=';')\n\n# Transform iso3 to upper and divide population\ndfgap['iso3'] = dfgap['iso3'].str.upper()\ndfgap['pop'] = dfgap['pop'] // 1000000\n\n# Filter years\ndfgap = dfgap[dfgap['year'] &gt; 1900]\n\n# Data Manipulation\n# ====================================================================\n# Copy Dataframe\ndf = dfgap.copy()\n\n# Create a list\ndfs = []\n\n# Interpolate monthly data\nfor iso3 in df['iso3'].unique():\n    temp_df = df[df['iso3'] == iso3].copy()\n    temp_df['date'] = pd.to_datetime(temp_df['year'], format='%Y')\n    temp_df = temp_df[['date', 'pop', 'gdpc']]\n    temp_df = temp_df.set_index('date').resample('ME').mean().interpolate(method='linear').reset_index()\n    temp_df['iso3'] = iso3\n    temp_df['year'] = temp_df['date'].dt.year \n    dfs.append(temp_df)\n\n# Concat dataframes    \ndf = pd.concat(dfs, ignore_index=True)\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='iso3', right_on='iso3')\ndf = df[['iso3', 'Country', 'Region', 'year', 'date', 'pop', 'gdpc']]\ndf = df[df['Region'].notna()]\n\n# Expand dataframe with population\ncolumns = df.columns\ndf = np.repeat(df.values, df['pop'].astype(int), axis=0)\ndf = pd.DataFrame(df, columns=columns)\n\n# Function to create a new distribution\ndef distribution(df):\n    average = df['gdpc'].mean()\n    inequality = np.geomspace(1, 10, len(df))\n    df['gdpcd'] = inequality * (average / np.mean(inequality))\n    \n    return df\n\ndf = df.groupby(['iso3', 'year', 'date']).apply(distribution).reset_index(drop=True)\n\n# Logarithmic distribution\ndf['gdpcdl'] = np.log(df['gdpcd'])\n\n# Logarithmic distribution\ndf['Region'] = np.where(df['iso3'] == 'CHN', 'China', df['Region'])\ndf['Region'] = np.where(df['iso3'] == 'USA', 'USA', df['Region'])\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\n\n# Create a palette\nfig, ax = plt.subplots(figsize=(16, 9))\n\ndef update(year):\n    ax.clear()\n    df_filtered = df[df['date'] == year]\n\n    # Calculate mean value\n    max_value = df_filtered['gdpcdl'].max()\n    mean_value = df_filtered['gdpcdl'].median()\n    mean_value_r = df_filtered['gdpcd'].median() // 365\n    population = len(df_filtered)\n    year = df_filtered['date'].min()\n\n    # Custom palette area\n    custom_area = {\n        'China': '#e3d6b1',\n        'Asia': '#fff3d0',\n        'Europe': '#ccdccd',\n        'Oceania': '#90a8b7',\n        'USA': '#f09c9c',\n        'Americas': '#fdcccc',\n        'Africa': '#ffe3ce'\n    }\n\n    # Custom palette line\n    custom_line = {\n        'China': '#cc9d0e',\n        'Asia': '#FFC107',\n        'Europe': '#004d00',\n        'Oceania': '#003366',\n        'USA': '#a60707',\n        'Americas': '#FF0000',\n        'Africa': '#FF6F00'\n    }\n\n    # Region Order\n    order_region = ['China', 'Asia', 'Africa', 'USA', 'Americas', 'Europe', 'Oceania'] \n\n    # Create kdeplot area and lines\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_area, fill=True, linewidth=1, linestyle='-', ax=ax)\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_line, fill=False, linewidth=1, linestyle='-', ax=ax)\n\n    # Configuration grid and labels\n    ax.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n    ax.text(0, 1.02, 'Evolution by region from 1980 to 2030', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n    ax.set_xlabel('Daily Income PPP ($US constant 2017)', fontsize=10, fontweight='bold')\n    ax.set_ylabel('Frequency of total population', fontsize=10, fontweight='bold')\n    ax.tick_params(axis='x', labelsize=9)\n    ax.tick_params(axis='y', labelsize=9)\n    ax.grid(axis='x')\n    ax.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n    ax.set_ylim(0, 0.4)\n    ax.set_xlim(3, 13)\n\n    # Functions to round axis\n    def round_to_nearest(value, step=0.05):\n        return np.floor(value / step) * step\n    def round_to_nearest_1(value, step=0.25):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_5(value, step=5):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_10(value, step=10):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_50(value, step=50):\n        return int(np.round(value / step) * step)\n\n    # Inverse logarhitmic xticklabels\n    xticks = np.linspace(3, 13, num=12)\n    ax.set_xticks(xticks)\n    ax.set_xticklabels([\n        # Condition 1\n        f'{round_to_nearest(np.exp(tick) / 365) :.2f}' if np.exp(tick) / 365 &lt; 1 else\n        # Condition 2\n        f'{round_to_nearest_1(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 5 else\n        # Condition 3\n        f'{round_to_nearest_5(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 100 else\n        # Condition 4\n        f'{round_to_nearest_10(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 500 else\n        # Condition 5\n        f'{round_to_nearest_50(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 10000 else\n        # Condition 6\n        f'{int(np.exp(tick) / 365)}'\n        for tick in xticks\n    ])\n\n    # Black color to xticklabels\n    for label in ax.get_xticklabels():\n        label.set_color('black')\n        \n    # Median line\n    ax.axvline(mean_value, color='darkred', linestyle='--', linewidth=0.5)\n    ax.text(\n        x=mean_value + (max_value * 0.01),\n        y=ax.get_ylim()[1] * 0.98,\n        s=f'Median: {mean_value_r:,.1f} $/day',\n        color='darkred',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Population label\n    ax.text(\n        0.02,\n        0.98,\n        s=f'Population: {population:,.0f} (M)',\n        transform=ax.transAxes,\n        color='dimgrey',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Add Year label\n    formatted_date = year.strftime('%Y') \n    ax.text(1, 1.06, f'{formatted_date}',\n        transform=ax.transAxes,\n        fontsize=22, ha='right', va='top',\n        fontweight='bold', color='#D3D3D3')\n\n    # Add a custom legend\n    legend_elements = [Line2D([0], [0], color=color, lw=4, label=region, alpha=0.4) for region, color in custom_line.items()]\n    legend = ax.legend(handles=legend_elements, title='Region', title_fontsize='10', fontsize='9', loc='upper right')\n    plt.setp(legend.get_title(), fontweight='bold')\n\n    # Add label \"poorest\" and \"richest\"\n    plt.text(0, -0.065, 'Poorest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkred', ha='left', va='center')\n    plt.text(0.95, -0.065, 'Richest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkblue', va='center')\n\n    # Add Data Source\n    plt.text(0, -0.1, 'Data Source: Gapminder (2024). GDP per capita Dataset.', \n        transform=plt.gca().transAxes, \n        fontsize=8, \n        color='gray')\n\n    # Add Notes\n    plt.text(0, -0.12, 'Notes: The distribution of values, based on GDP per capita, has been calculated using a logarithmic scale ranging from 1 to 10 and adjusted proportionally to the population size of each country.', \n        transform=plt.gca().transAxes,\n        fontsize=8, \n        color='gray')\n\n# Configurate animation\nyears = sorted(df['date'].unique())\nani = animation.FuncAnimation(fig, update, frames=years, repeat=False, interval=50, blit=False)\n\n# Save the animation :)\nani.save('C:/Users/guillem.maya/Downloads/FIG_GDP_Capita_Distribution_PPP_KDEPLOT_GAPMINDER.webp', writer='imagemagick', fps=80)\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/2025/distribution-mountains-gdpc/index.html#summary",
    "href": "posts/2025/distribution-mountains-gdpc/index.html#summary",
    "title": "Distribution of Global GDP: Visualizing Income Mountains",
    "section": "",
    "text": "A plot that shows the evolution of Daily Income based on GDP per Capita ($US constant 2017) from 1900 to 2100.\n\n\nCode\n# Libraries\n# =====================================================================\nimport requests\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport matplotlib.ticker as ticker\nfrom matplotlib.lines import Line2D\n\n# Data Extraction (Countries)\n# =====================================================================\n# Extract JSON and bring data to a dataframe\nurl = 'https://raw.githubusercontent.com/guillemmaya92/world_map/main/Dim_Country.json'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndf = pd.DataFrame.from_dict(data, orient='index').reset_index()\ndf_countries = df.rename(columns={'index': 'iso3'})\n\n# Data Extraction (GAPMINDER)\n# ====================================================================\n# URL Github\nurlgap = 'https://raw.githubusercontent.com/guillemmaya92/world_map/refs/heads/main/gapminder-gdp.csv'\ndfgap = pd.read_csv(urlgap, delimiter=';')\n\n# Transform iso3 to upper and divide population\ndfgap['iso3'] = dfgap['iso3'].str.upper()\ndfgap['pop'] = dfgap['pop'] // 1000000\n\n# Filter years\ndfgap = dfgap[dfgap['year'] &gt; 1900]\n\n# Data Manipulation\n# ====================================================================\n# Copy Dataframe\ndf = dfgap.copy()\n\n# Create a list\ndfs = []\n\n# Interpolate monthly data\nfor iso3 in df['iso3'].unique():\n    temp_df = df[df['iso3'] == iso3].copy()\n    temp_df['date'] = pd.to_datetime(temp_df['year'], format='%Y')\n    temp_df = temp_df[['date', 'pop', 'gdpc']]\n    temp_df = temp_df.set_index('date').resample('ME').mean().interpolate(method='linear').reset_index()\n    temp_df['iso3'] = iso3\n    temp_df['year'] = temp_df['date'].dt.year \n    dfs.append(temp_df)\n\n# Concat dataframes    \ndf = pd.concat(dfs, ignore_index=True)\n\n# Merge queries\ndf = df.merge(df_countries, how='left', left_on='iso3', right_on='iso3')\ndf = df[['iso3', 'Country', 'Region', 'year', 'date', 'pop', 'gdpc']]\ndf = df[df['Region'].notna()]\n\n# Expand dataframe with population\ncolumns = df.columns\ndf = np.repeat(df.values, df['pop'].astype(int), axis=0)\ndf = pd.DataFrame(df, columns=columns)\n\n# Function to create a new distribution\ndef distribution(df):\n    average = df['gdpc'].mean()\n    inequality = np.geomspace(1, 10, len(df))\n    df['gdpcd'] = inequality * (average / np.mean(inequality))\n    \n    return df\n\ndf = df.groupby(['iso3', 'year', 'date']).apply(distribution).reset_index(drop=True)\n\n# Logarithmic distribution\ndf['gdpcdl'] = np.log(df['gdpcd'])\n\n# Logarithmic distribution\ndf['Region'] = np.where(df['iso3'] == 'CHN', 'China', df['Region'])\ndf['Region'] = np.where(df['iso3'] == 'USA', 'USA', df['Region'])\n\nprint(df)\n\n# Data Visualization\n# =====================================================================\n# Seaborn figure style\nsns.set(style=\"whitegrid\")\n\n# Create a palette\nfig, ax = plt.subplots(figsize=(16, 9))\n\ndef update(year):\n    ax.clear()\n    df_filtered = df[df['date'] == year]\n\n    # Calculate mean value\n    max_value = df_filtered['gdpcdl'].max()\n    mean_value = df_filtered['gdpcdl'].median()\n    mean_value_r = df_filtered['gdpcd'].median() // 365\n    population = len(df_filtered)\n    year = df_filtered['date'].min()\n\n    # Custom palette area\n    custom_area = {\n        'China': '#e3d6b1',\n        'Asia': '#fff3d0',\n        'Europe': '#ccdccd',\n        'Oceania': '#90a8b7',\n        'USA': '#f09c9c',\n        'Americas': '#fdcccc',\n        'Africa': '#ffe3ce'\n    }\n\n    # Custom palette line\n    custom_line = {\n        'China': '#cc9d0e',\n        'Asia': '#FFC107',\n        'Europe': '#004d00',\n        'Oceania': '#003366',\n        'USA': '#a60707',\n        'Americas': '#FF0000',\n        'Africa': '#FF6F00'\n    }\n\n    # Region Order\n    order_region = ['China', 'Asia', 'Africa', 'USA', 'Americas', 'Europe', 'Oceania'] \n\n    # Create kdeplot area and lines\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_area, fill=True, linewidth=1, linestyle='-', ax=ax)\n    sns.kdeplot(data=df_filtered, x=\"gdpcdl\", hue=\"Region\", bw_adjust=2.5, hue_order=order_region, multiple=\"stack\", alpha=1, palette=custom_line, fill=False, linewidth=1, linestyle='-', ax=ax)\n\n    # Configuration grid and labels\n    ax.text(0, 1.05, 'Distribution of Global GDP', fontsize=13, fontweight='bold', ha='left', transform=plt.gca().transAxes)\n    ax.text(0, 1.02, 'Evolution by region from 1980 to 2030', fontsize=9, color='#262626', ha='left', transform=plt.gca().transAxes)\n    ax.set_xlabel('Daily Income PPP ($US constant 2017)', fontsize=10, fontweight='bold')\n    ax.set_ylabel('Frequency of total population', fontsize=10, fontweight='bold')\n    ax.tick_params(axis='x', labelsize=9)\n    ax.tick_params(axis='y', labelsize=9)\n    ax.grid(axis='x')\n    ax.grid(axis='y', linestyle='--', linewidth=0.5, color='lightgray')\n    ax.set_ylim(0, 0.4)\n    ax.set_xlim(3, 13)\n\n    # Functions to round axis\n    def round_to_nearest(value, step=0.05):\n        return np.floor(value / step) * step\n    def round_to_nearest_1(value, step=0.25):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_5(value, step=5):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_10(value, step=10):\n        return int(np.round(value / step) * step)\n    def round_to_nearest_50(value, step=50):\n        return int(np.round(value / step) * step)\n\n    # Inverse logarhitmic xticklabels\n    xticks = np.linspace(3, 13, num=12)\n    ax.set_xticks(xticks)\n    ax.set_xticklabels([\n        # Condition 1\n        f'{round_to_nearest(np.exp(tick) / 365) :.2f}' if np.exp(tick) / 365 &lt; 1 else\n        # Condition 2\n        f'{round_to_nearest_1(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 5 else\n        # Condition 3\n        f'{round_to_nearest_5(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 100 else\n        # Condition 4\n        f'{round_to_nearest_10(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 500 else\n        # Condition 5\n        f'{round_to_nearest_50(np.exp(tick) / 365)}' if np.exp(tick) / 365 &lt; 10000 else\n        # Condition 6\n        f'{int(np.exp(tick) / 365)}'\n        for tick in xticks\n    ])\n\n    # Black color to xticklabels\n    for label in ax.get_xticklabels():\n        label.set_color('black')\n        \n    # Median line\n    ax.axvline(mean_value, color='darkred', linestyle='--', linewidth=0.5)\n    ax.text(\n        x=mean_value + (max_value * 0.01),\n        y=ax.get_ylim()[1] * 0.98,\n        s=f'Median: {mean_value_r:,.1f} $/day',\n        color='darkred',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Population label\n    ax.text(\n        0.02,\n        0.98,\n        s=f'Population: {population:,.0f} (M)',\n        transform=ax.transAxes,\n        color='dimgrey',\n        verticalalignment='top',\n        horizontalalignment='left',\n        fontsize=10,\n        weight='bold')\n\n    # Add Year label\n    formatted_date = year.strftime('%Y') \n    ax.text(1, 1.06, f'{formatted_date}',\n        transform=ax.transAxes,\n        fontsize=22, ha='right', va='top',\n        fontweight='bold', color='#D3D3D3')\n\n    # Add a custom legend\n    legend_elements = [Line2D([0], [0], color=color, lw=4, label=region, alpha=0.4) for region, color in custom_line.items()]\n    legend = ax.legend(handles=legend_elements, title='Region', title_fontsize='10', fontsize='9', loc='upper right')\n    plt.setp(legend.get_title(), fontweight='bold')\n\n    # Add label \"poorest\" and \"richest\"\n    plt.text(0, -0.065, 'Poorest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkred', ha='left', va='center')\n    plt.text(0.95, -0.065, 'Richest',\n        transform=ax.transAxes,\n        fontsize=10, fontweight='bold', color='darkblue', va='center')\n\n    # Add Data Source\n    plt.text(0, -0.1, 'Data Source: Gapminder (2024). GDP per capita Dataset.', \n        transform=plt.gca().transAxes, \n        fontsize=8, \n        color='gray')\n\n    # Add Notes\n    plt.text(0, -0.12, 'Notes: The distribution of values, based on GDP per capita, has been calculated using a logarithmic scale ranging from 1 to 10 and adjusted proportionally to the population size of each country.', \n        transform=plt.gca().transAxes,\n        fontsize=8, \n        color='gray')\n\n# Configurate animation\nyears = sorted(df['date'].unique())\nani = animation.FuncAnimation(fig, update, frames=years, repeat=False, interval=50, blit=False)\n\n# Save the animation :)\nani.save('C:/Users/guillem.maya/Downloads/FIG_GDP_Capita_Distribution_PPP_KDEPLOT_GAPMINDER.webp', writer='imagemagick', fps=80)\n\n# Print it!\nplt.show()"
  },
  {
    "objectID": "posts/2025/polar-axis/index.html",
    "href": "posts/2025/polar-axis/index.html",
    "title": "Polar Axis demonstration",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see Figure 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1: A line plot on a polar axis\n\n\n\n\n\n\n\n\n Back to top"
  }
]